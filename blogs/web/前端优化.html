<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端优化 | jun的个人空间</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="A simple and beautiful vuepress blog theme .">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/blog/assets/css/0.styles.22e22db1.css" as="style"><link rel="preload" href="/blog/assets/js/app.2e9aaf02.js" as="script"><link rel="preload" href="/blog/assets/js/3.df7e12f5.js" as="script"><link rel="preload" href="/blog/assets/js/1.71a2a4d1.js" as="script"><link rel="preload" href="/blog/assets/js/31.eeacc110.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.06cfad2a.js"><link rel="prefetch" href="/blog/assets/js/11.df88bce0.js"><link rel="prefetch" href="/blog/assets/js/12.041115a7.js"><link rel="prefetch" href="/blog/assets/js/13.f0185e2a.js"><link rel="prefetch" href="/blog/assets/js/14.5a045b81.js"><link rel="prefetch" href="/blog/assets/js/15.7164e1d7.js"><link rel="prefetch" href="/blog/assets/js/16.f9c02261.js"><link rel="prefetch" href="/blog/assets/js/17.d889275f.js"><link rel="prefetch" href="/blog/assets/js/18.11d93686.js"><link rel="prefetch" href="/blog/assets/js/19.c7295ef8.js"><link rel="prefetch" href="/blog/assets/js/20.ef0bf1ef.js"><link rel="prefetch" href="/blog/assets/js/21.c0808f41.js"><link rel="prefetch" href="/blog/assets/js/22.411bd3f9.js"><link rel="prefetch" href="/blog/assets/js/23.18a8e710.js"><link rel="prefetch" href="/blog/assets/js/24.ca6e4b20.js"><link rel="prefetch" href="/blog/assets/js/25.0d72f462.js"><link rel="prefetch" href="/blog/assets/js/26.c4c011ae.js"><link rel="prefetch" href="/blog/assets/js/27.eb3de618.js"><link rel="prefetch" href="/blog/assets/js/28.f8e2a1e2.js"><link rel="prefetch" href="/blog/assets/js/29.f03180e4.js"><link rel="prefetch" href="/blog/assets/js/30.36ab1f30.js"><link rel="prefetch" href="/blog/assets/js/32.20a67723.js"><link rel="prefetch" href="/blog/assets/js/33.eedb8eae.js"><link rel="prefetch" href="/blog/assets/js/34.5746a48f.js"><link rel="prefetch" href="/blog/assets/js/35.5aae019c.js"><link rel="prefetch" href="/blog/assets/js/36.8cf983a3.js"><link rel="prefetch" href="/blog/assets/js/37.52c37ca6.js"><link rel="prefetch" href="/blog/assets/js/38.a2ae90d0.js"><link rel="prefetch" href="/blog/assets/js/39.491dc017.js"><link rel="prefetch" href="/blog/assets/js/4.868230a6.js"><link rel="prefetch" href="/blog/assets/js/40.aa1410cd.js"><link rel="prefetch" href="/blog/assets/js/5.ea5f743c.js"><link rel="prefetch" href="/blog/assets/js/6.c6d16241.js"><link rel="prefetch" href="/blog/assets/js/7.e9233ad5.js"><link rel="prefetch" href="/blog/assets/js/8.7ae95209.js"><link rel="prefetch" href="/blog/assets/js/9.3304f7f8.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.22e22db1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-945f89ac><div data-v-945f89ac><div id="loader-wrapper" class="loading-wrapper" data-v-2c578df8 data-v-945f89ac data-v-945f89ac><div class="loader-main" data-v-2c578df8><div data-v-2c578df8></div><div data-v-2c578df8></div><div data-v-2c578df8></div><div data-v-2c578df8></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-3dc17307 data-v-945f89ac data-v-945f89ac><h3 class="title" style="display:none;" data-v-3dc17307 data-v-3dc17307>jun的个人空间</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-3dc17307 data-v-3dc17307><input type="password" value="" data-v-3dc17307> <span data-v-3dc17307>Konck! Knock!</span> <button data-v-3dc17307>OK</button></label> <div class="footer" style="display:none;" data-v-3dc17307 data-v-3dc17307><span data-v-3dc17307><i class="iconfont reco-theme" data-v-3dc17307></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-3dc17307>vuePress-theme-reco</a></span> <span data-v-3dc17307><i class="iconfont reco-copyright" data-v-3dc17307></i> <a data-v-3dc17307><span data-v-3dc17307>jun</span>
            
          <span data-v-3dc17307>2017 - </span>
          2021
        </a></span></div></div> <div class="hide" data-v-945f89ac><header class="navbar" data-v-945f89ac><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="jun的个人空间" class="logo"> <span class="site-name">jun的个人空间</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/系统教程/" class="nav-link"><i class="iconfont undefined"></i>
  系统教程
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/环境构建/" class="nav-link"><i class="iconfont undefined"></i>
  环境构建
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/K8S/" class="nav-link"><i class="iconfont undefined"></i>
  K8S
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/前端/" class="nav-link"><i class="iconfont undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/工具/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/性能优化/" class="nav-link"><i class="iconfont undefined"></i>
  性能优化
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/docs/theme-reco/" class="nav-link"><i class="iconfont undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-945f89ac></div> <aside class="sidebar" data-v-945f89ac><div class="personal-info-wrapper" data-v-661bee24><img src="/blog/avatar.jpg" alt="author-avatar" class="personal-img" data-v-661bee24> <h3 class="name" data-v-661bee24>
    jun
  </h3> <div class="num" data-v-661bee24><div data-v-661bee24><h3 data-v-661bee24>26</h3> <h6 data-v-661bee24>文章</h6></div> <div data-v-661bee24><h3 data-v-661bee24>31</h3> <h6 data-v-661bee24>标签</h6></div></div> <hr data-v-661bee24></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/系统教程/" class="nav-link"><i class="iconfont undefined"></i>
  系统教程
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/环境构建/" class="nav-link"><i class="iconfont undefined"></i>
  环境构建
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/K8S/" class="nav-link"><i class="iconfont undefined"></i>
  K8S
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/前端/" class="nav-link"><i class="iconfont undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/工具/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/性能优化/" class="nav-link"><i class="iconfont undefined"></i>
  性能优化
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/docs/theme-reco/" class="nav-link"><i class="iconfont undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端优化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#前端优化方案" class="sidebar-link">前端优化方案</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#确认哪些页面需要优化" class="sidebar-link">确认哪些页面需要优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#建立监控体系" class="sidebar-link">建立监控体系</a></li><li class="sidebar-sub-header"><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#确定采集指标" class="sidebar-link">确定采集指标</a></li><li class="sidebar-sub-header"><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#根据监控信息分析页面" class="sidebar-link">根据监控信息分析页面</a></li></ul></li><li><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#针对性优化" class="sidebar-link">针对性优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#资源优化" class="sidebar-link">资源优化</a></li><li class="sidebar-sub-header"><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#构建优化" class="sidebar-link">构建优化</a></li><li class="sidebar-sub-header"><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#传输优化" class="sidebar-link">传输优化</a></li><li class="sidebar-sub-header"><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#网络优化" class="sidebar-link">网络优化</a></li><li class="sidebar-sub-header"><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html#参考文章" class="sidebar-link">参考文章</a></li></ul></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-3dc17307 data-v-945f89ac><h3 class="title" style="display:none;" data-v-3dc17307 data-v-3dc17307>前端优化</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-3dc17307 data-v-3dc17307><input type="password" value="" data-v-3dc17307> <span data-v-3dc17307>Konck! Knock!</span> <button data-v-3dc17307>OK</button></label> <div class="footer" style="display:none;" data-v-3dc17307 data-v-3dc17307><span data-v-3dc17307><i class="iconfont reco-theme" data-v-3dc17307></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-3dc17307>vuePress-theme-reco</a></span> <span data-v-3dc17307><i class="iconfont reco-copyright" data-v-3dc17307></i> <a data-v-3dc17307><span data-v-3dc17307>jun</span>
            
          <span data-v-3dc17307>2017 - </span>
          2021
        </a></span></div></div> <div data-v-945f89ac><main class="page"><div class="page-title" style="display:none;"><h1>前端优化</h1> <hr> <div data-v-32e7eb69><i class="iconfont reco-account" data-v-32e7eb69><span data-v-32e7eb69>jun</span></i> <i class="iconfont reco-date" data-v-32e7eb69><span data-v-32e7eb69>2021-11-09 15:28:21</span></i> <i class="iconfont reco-eye" data-v-32e7eb69><span id="/blog/blogs/web/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-32e7eb69><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-32e7eb69><span class="tag-item" data-v-32e7eb69>前端优化</span><span class="tag-item" data-v-32e7eb69>前端监控</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><h2 id="前端优化方案"><a href="#前端优化方案" class="header-anchor">#</a> 前端优化方案</h2> <blockquote><p>先来一道面试必考题：「<strong>聊一聊你怎么做前端优化？</strong>」 那么一个相对完善的前端优化方案应该是怎么样的呢？</p></blockquote> <p>在过去的经验中，我认为：首先需要知道哪些页面需要优化，需要怎么样的优化，然后才能针对性的优化。所以我会将前端优化分为以下几个步骤：</p> <ul><li>确认哪些页面需要优化
<ul><li>建立监控体系</li> <li>确定监控指标</li> <li>根据监控信息分析页面</li></ul></li> <li>针对性优化
<ul><li>资源优化</li> <li>构建优化</li> <li>传输优化</li> <li>网络优化</li></ul></li></ul> <h2 id="确认哪些页面需要优化"><a href="#确认哪些页面需要优化" class="header-anchor">#</a> 确认哪些页面需要优化</h2> <h3 id="建立监控体系"><a href="#建立监控体系" class="header-anchor">#</a> 建立监控体系</h3> <p>第一步我们需要建立一套前端的性能监控体系。前端性能监控目前主要有两种方案：</p> <ol><li>第三方提供的成熟服务：例如 阿里云ARMS、听云、监控宝等</li> <li>自主搭建</li></ol> <p>这里就不赘述各类第三方平台提供的服务了，主要讲明下自主搭建前端性能监控平台大概的实现思路。</p> <h3 id="确定采集指标"><a href="#确定采集指标" class="header-anchor">#</a> 确定采集指标</h3> <p>在前端监控方面，一般我们关注两个方向，<strong>性能和稳定</strong>。所以我们需要采集的指标大概有一下4个指标。</p> <ul><li><p><strong>RUM</strong> <strong>(Real User Monitoring) 指标</strong>：包括 FP, TTI, FCP, FMP, FID, MPFID。</p></li> <li><p><strong>Navigation Timing</strong>：包括 DNS, TCP, DOM 解析等阶段的指标。</p></li> <li><p><strong>JS Error</strong>：解析后可以细分为运行时异常、以及静态资源异常。</p></li> <li><p><strong>请求异常</strong>：采集ajax请求异常。</p></li></ul> <p><em>那么接下来我们来逐个分析各个指标如何采集</em></p> <h4 id="rum指标"><a href="#rum指标" class="header-anchor">#</a> RUM指标</h4> <blockquote><p>核心 Web 指标是指适用于所有网页的 Web 指标子集，每位网站开发者都应该去测量这些指标，并且这些指标还将显示在所有 Google 工具中。每项核心 Web 指标代表用户体验的一个不同方面，能够进行<a href="https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fuser-centric-performance-metrics%2F%23how-metrics-are-measured" title="https://web.dev/user-centric-performance-metrics/#how-metrics-are-measured" target="_blank" rel="noopener noreferrer">实际<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>测量，并且反映出<a href="https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fuser-centric-performance-metrics%2F%23how-metrics-are-measured" title="https://web.dev/user-centric-performance-metrics/#how-metrics-are-measured" target="_blank" rel="noopener noreferrer">以用户为中心<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的关键结果的真实体验。</p> <p>核心 Web 指标的构成指标会随着时间的推移而<a href="https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fvitals%2F%23evolving-web-vitals" title="https://web.dev/vitals/#evolving-web-vitals" target="_blank" rel="noopener noreferrer">发展<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。当前的指标构成侧重于用户体验的三个方面：<strong>加载性能</strong>、<strong>交互性</strong>、<strong>视觉稳定性</strong></p> <p>主要包含包括以下指标（及各指标相应的阈值）：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2a8f829dbe34cb98ac1b15c87d6236c~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211014135446592"></p></blockquote> <h5 id="lcp-、fid、cls"><a href="#lcp-、fid、cls" class="header-anchor">#</a> LCP 、FID、CLS</h5> <p><strong>最大内容绘制 (LCP）</strong>：即 <code>Largest Contentful Paint</code>，测量加载性能。为了提供良好的用户体验，<code>LCP</code> 应在页面首次开始加载后的<strong>2.5 秒</strong>内发生。</p> <p><strong>首次交互时间（FID）</strong>：即 <code>First Input Delay</code>，记录页面加载阶段，用户首次交互操作的延时时间。<code>FID</code> 指标影响用户对页面交互性和响应性的第一印象。</p> <p><strong>累积布局偏移 (CLS）</strong>：即 <code>Cumulative Layout Shift</code>，测量视觉稳定性。为了提供良好的用户体验，页面的 <code>CLS</code> 应保持在 <strong>0.1</strong> 或更少。</p> <p>对于<code>LCP</code>、<code>FID</code>、<code>CLS</code>我们可以直接使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FGoogleChrome%2Fweb-vitals" title="https://github.com/GoogleChrome/web-vitals" target="_blank" rel="noopener noreferrer">web-vitals<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来进行采集，采集代码如下</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>    <span class="token keyword">import</span> <span class="token punctuation">{</span> getLCP<span class="token punctuation">,</span> getFID<span class="token punctuation">,</span> getCLS <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'web-vitals'</span><span class="token punctuation">;</span>
    
    <span class="token function">getLCP</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'LCP'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">getFID</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'FID'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">getCLS</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'CLS'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25f9694ac58f4cc4a32ebe33b7ce20fa~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211014153344548"></p> <p><em>除开上述的 3个指标，我们还可以通过以下指标进行监控</em></p> <h5 id="fp、fcp"><a href="#fp、fcp" class="header-anchor">#</a> FP、FCP</h5> <p><strong>首次绘制时间（ FP ）</strong> ：即 <code>First Paint</code>，为首次渲染的时间点。</p> <p><strong>首次内容绘制时间（ FCP ）</strong> ：即 <code>First Contentful Paint</code>，为首次有内容渲染的时间点。</p> <p>这两个指标看起来大同小异，但是 <code>FP</code> 发生的时间一定早于等于 <code>FCP</code>。<code>FP</code> 指的是绘制像素，比如说页面的背景色是灰色的，那么在显示灰色背景时就记录下了 <code>FP</code> 指标。但是此时 <code>DOM</code> 内容还没开始绘制，可能需要文件下载、解析等过程，只有当 <code>DOM</code> 内容发生变化才会触发，比如说渲染出了一段文字，此时就会记录下 <code>FCP</code> 指标。因此说我们可以把这两个指标认为是和白屏时间相关的指标，所以肯定是最快越好。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21de3bd5d7b7455c8925ba713c2b46a9~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p> <p>根据官方推荐的时间，我们应该把 <code>FP</code> 和 <code>FCP</code> 压缩到<strong>2秒</strong>内。</p> <p>采集代码如下</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>    window<span class="token punctuation">.</span>performance<span class="token punctuation">.</span><span class="token function">getEntriesByType</span><span class="token punctuation">(</span><span class="token string">'paint'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2671b4459b1849049db7919a42639357~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211014155422915"></p> <h5 id="tti"><a href="#tti" class="header-anchor">#</a> TTI</h5> <p><strong>完全可交互时间（TTI）</strong>：即 <code>Time to interactive</code>，记录从页面加载开始，到页面处于完全可交互状态所花费的时间。</p> <p>获取 <code>TTI</code> 的规则如下：</p> <ul><li><p>从首次内容绘制(<code>FCP</code>)开始</p></li> <li><p>向前搜索 5秒，没有长任务，且不能超过2个get请求</p></li> <li><p>向后搜索最后一个长任务（耗时超过 <code>50</code> 毫秒的任务），如果没有长任务被发现就到 <code>FCP</code> 停止</p></li> <li><p><code>TTI</code> 的时间是最后一个长任务的时间，如果没有长任务的话，则等于 <code>FCP</code> 时间</p></li></ul> <p>Google 希望将 <code>TTI</code> 指标标准化，并通过 <code>PerformanceObserver</code> 在浏览器中公开，但目前并不支持。</p> <p>目前只能通过一个 <code>polyfill</code>，检测目前的 <code>TTI</code>，适用于所有支持 <code>Long Tasks API</code> 的浏览器。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da3ba6fb613f4e668edae75413bf177d~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211014160055611"></p> <p>根据官方推荐的时间，我们应该把 <code>TTI</code> 控制在到<strong>3.8秒</strong>内</p> <p>采集代码如下</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>    <span class="token keyword">import</span> ttiPolyfill <span class="token keyword">from</span> <span class="token string">'tti-polyfill'</span>
    
    <span class="token comment">// collect the longtask</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>PerformanceLongTaskTiming<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      window<span class="token punctuation">.</span>__tti <span class="token operator">=</span> <span class="token punctuation">{</span> e<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> entry <span class="token keyword">of</span> list<span class="token punctuation">.</span><span class="token function">getEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// observe the longtask to get the time to interactive (TTI)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>entryType <span class="token operator">===</span> <span class="token string">'longtask'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            window<span class="token punctuation">.</span>__tti<span class="token punctuation">.</span>e<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">{</span> entryTypes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'longtask'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    ttiPolyfill<span class="token punctuation">.</span><span class="token function">getFirstConsistentlyInteractive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">tti</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TTI'</span><span class="token punctuation">,</span> tti<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h4 id="navigation-timing"><a href="#navigation-timing" class="header-anchor">#</a> Navigation Timing</h4> <p>这里我们关注的指标主要有</p> <ul><li><code>DNS</code> 查询耗时</li> <li><code>TCP</code> 链接耗时</li> <li><code>request</code> 耗时</li> <li>解析 <code>DOM</code> 树耗时</li> <li>白屏时间</li> <li><code>domready</code> 时间</li> <li><code>onload</code> 时间</li></ul> <p>获取的方式很简单，我们可以直接通过<code>PerformanceTiming</code>来得到他们</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'load'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> timing <span class="token operator">=</span> window<span class="token punctuation">.</span>performance<span class="token punctuation">.</span>timing<span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'DNS查询耗时：'</span><span class="token punctuation">,</span> timing<span class="token punctuation">.</span>domainLookupEnd <span class="token operator">-</span> timing<span class="token punctuation">.</span>domainLookupStart<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TCP链接耗时：'</span><span class="token punctuation">,</span> timing<span class="token punctuation">.</span>connectEnd <span class="token operator">-</span> timing<span class="token punctuation">.</span>connectStart<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request耗时：'</span><span class="token punctuation">,</span> timing<span class="token punctuation">.</span>responseEnd <span class="token operator">-</span> timing<span class="token punctuation">.</span>responseStart<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'解析DOM树耗时：'</span><span class="token punctuation">,</span> timing<span class="token punctuation">.</span>domComplete <span class="token operator">-</span> timing<span class="token punctuation">.</span>domInteractive<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'白屏时间：'</span><span class="token punctuation">,</span> timing<span class="token punctuation">.</span>domLoading <span class="token operator">-</span> timing<span class="token punctuation">.</span>fetchStart<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'domready时间：'</span><span class="token punctuation">,</span> timing<span class="token punctuation">.</span>domContentLoadedEventEnd <span class="token operator">-</span> timing<span class="token punctuation">.</span>fetchStart<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'onload时间：'</span><span class="token punctuation">,</span> timing<span class="token punctuation">.</span>loadEventEnd <span class="token operator">-</span> timing<span class="token punctuation">.</span>fetchStart<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="js-error"><a href="#js-error" class="header-anchor">#</a> JS Error</h4> <p>在采集<code>JS Error</code>这块，我们可以采用<code>error</code>和<code>unhandledrejection</code>这两个事件来捕获 JS 错误及<code>Promise</code>未处理的<code>rejection</code>异常。</p> <p>下面附上简易代码</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>    window<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">errorMsg<span class="token punctuation">,</span> url<span class="token punctuation">,</span> lineNumber<span class="token punctuation">,</span> columnNumber<span class="token punctuation">,</span> errorObj</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> errorStack <span class="token operator">=</span> errorObj <span class="token operator">?</span> errorObj<span class="token punctuation">.</span>stack <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token comment">// 这里进行上报</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>errorMsg<span class="token punctuation">,</span> url<span class="token punctuation">,</span> lineNumber<span class="token punctuation">,</span> columnNumber<span class="token punctuation">,</span> errorStack<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    window<span class="token punctuation">.</span><span class="token function-variable function">onunhandledrejection</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> errorMsg <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> errorStack <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> e<span class="token punctuation">.</span>reason <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        errorMsg <span class="token operator">=</span> e<span class="token punctuation">.</span>reason<span class="token punctuation">.</span>message<span class="token punctuation">;</span>
        errorStack <span class="token operator">=</span> e<span class="token punctuation">.</span>reason<span class="token punctuation">.</span>stack<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        errorMsg <span class="token operator">=</span> e<span class="token punctuation">.</span>reason<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 这里进行上报</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>errorMsg<span class="token punctuation">,</span> errorStack<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h4 id="请求异常"><a href="#请求异常" class="header-anchor">#</a> 请求异常</h4> <p>捕获请求异常，我们可以通过重写<code>window.fetch</code>及<code>XMLHttpRequest</code>来实现。</p> <h3 id="根据监控信息分析页面"><a href="#根据监控信息分析页面" class="header-anchor">#</a> 根据监控信息分析页面</h3> <blockquote><p>上面只是抛砖引玉的讲了指标的采集方法。在实际操作中，一套前端监控体系的搭建是一个很庞大的工程，不仅仅在数据采集这块，很多时候我们还需要数据分类，数据清洗，数据展示等等各个方面。举个例子：在采集信息时的因为检测数据可能会很大，那么我们需要就做本地化存储，方便进行数据压缩合并，然后上报可能采用消息队列防止上报丢失，利用 <code>Navigator.sendBeacon</code> 委托浏览器在页面关闭后上报数据等等。</p></blockquote> <p>当我们拥有一套完整的监控体系，那么接下来可以基于上面给出的监控指标来对页面进行针对性优化。哪个页面需要优化并没有一个标准的答案，这一切都需要根据自身业务及投入产出比来看。</p> <p>这里也给出一个优化目标的建议 <strong>目标:比你最快的竞争对手至少快20%</strong></p> <p>根据<strong>用户心理学研究</strong>，如果想让用户感觉你的 <code>web</code> 网站比其它竞品快，那你必须比它们快 <strong>20%</strong> 以上。研究你的主要竞争对手，收集它们在移动设备和台式机上的性能指标，并设置阈值来帮助你超越竞争对手。但是，要获取准确的性能指标并制定目标，务必先通过研究分析来全面了解用户体验。然后，你可以根据 90％ 的主要用户的反馈和经验来模拟测试。</p> <h2 id="针对性优化"><a href="#针对性优化" class="header-anchor">#</a> 针对性优化</h2> <h3 id="资源优化"><a href="#资源优化" class="header-anchor">#</a> 资源优化</h3> <h4 id="使用-brotli-进行纯文本压缩"><a href="#使用-brotli-进行纯文本压缩" class="header-anchor">#</a> 使用 Brotli 进行纯文本压缩</h4> <p>2015 年，Google推出了<code>Brotli</code>，这是一种全新的开源无损数据格式，<strong>并被现在所有现代浏览器支持</strong>。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2aa423c66b94c52ac5153d4cd8cc7a1~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211014180650040"></p> <p><code>Brotli</code>有比<code>Gzip</code>和<code>Deflate</code>更高的压缩率，但是同时也需要更长的压缩时间，所以在请求的时候实时进行压缩并不是一个很好的办法。但我们可以预先对静态文件进行压缩，然后直接提供给客户端，这样我们就避免了 <code>Brotli</code> 压缩效率低的问题，同时使用这个方式，我们可以使用压缩质量最高的等级去压缩文件，最大程度的去减小文件的大小。</p> <p>另外，由于不是所有浏览器都支持 <code>Brotli</code> 算法，所以在服务端我们需要同时提供两种文件，一个是经过 <code>Brotli</code> 压缩的文件，一个是原始文件，在浏览器不支持 <code>Brotli</code> 的情况下，我们可以使用 <code>gzip</code> 去压缩原始文件提供给客户端。</p> <p><code>Brotli</code>可用于任何纯文本的内容如 <code>HTML</code>，<code>CSS</code>，<code>SVG</code>，<code>JavaScript</code> 等。</p> <p>使用最高压缩比配置的<strong>Brotli + Gzip 预压缩静态资源</strong>，并使用 <code>Brotli</code> 配置 3～5 级压缩比来快速压缩 <code>HTML</code>。确保服务器正确处理 <code>Brotli</code> 或 <code>gzip</code> 的内容协商头。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a14d6a8408244419b1df45d58dba004c~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211014180532153"></p> <h4 id="使用响应式图像和-webp"><a href="#使用响应式图像和-webp" class="header-anchor">#</a> 使用响应式图像和 WebP</h4> <p><code>WebP</code>图片是一种新的图像格式，由 Google 开发。与 <code>png</code>、<code>jpg</code> 相比，相同的视觉体验下，<code>WebP</code> 图像的尺寸缩小了大约<strong>30％</strong>。另外，<code>WebP</code>图像格式还支持有损压缩、无损压缩、透明和动画。理论上完全可以替代<code>png</code>、<code>jpg</code>、<code>gif</code>等图片格式，不过目前<code>WebP</code>的还没有得到全面的支持，但是我们还是能够通过兜底方案来使用它。</p> <p>所以在使用图片时尽可能使用具有 <code>srcset</code>，<code>sizes</code> 和 <code>&lt;picture&gt;</code> 元素的<strong>响应式图像</strong>。在使用它的同时，还可以通过 <code>&lt;picture&gt;</code> 元素和 <code>JPEG</code> 兜底来使用<code>WebP</code> 格式。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/199383409f4544b1828ac532b895d884~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211014182421007"></p> <p>但是<code>WebP</code>并非毫无缺点，它不支持<strong>像 JPEG 那样的渐进式渲染</strong>，这就是为什么用户使用 <code>JPEG</code> 可能会更快地看到实际图像！尽管 <code>WebP</code> 图像的网络加载速度可能会更快。使用 <code>JPEG</code> 我们可以用一半甚至四分之一的时间就提供给用户一个比较「像样」的体验，并在后续加载其余数据，而不是像 <code>WebP</code> 那样只有半空的图像。所以这就看我们想要的是什么：使用 <code>WebP</code>，将减少图像大小；使用 <code>JPEG</code>，将提高图像的可感知性。</p> <h4 id="图像是否经过适当优化？"><a href="#图像是否经过适当优化？" class="header-anchor">#</a> 图像是否经过适当优化？</h4> <p>在我们的项目中，快速加载图像非常重要，所以在使用到图片的时候需要注意：</p> <ul><li><p>确保<code>JPEG</code>是渐进式渲染的，并使用<code>mozJPEG</code>或<code>Guetzli</code>压缩。</p></li> <li><p>使用<code>Pingo</code>压缩<code>png</code></p></li> <li><p>使用<code>SVGO</code>或<code>SVGOMG</code>对<code>SVG</code>进行压缩</p></li> <li><p>对图片或者<code>iframe</code>进行懒加载</p></li> <li><p>如果可能建议使用循环播放的<code>video</code>或者<code>WebP</code>代替 <code>gif</code></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/469dfc84f83e42d3adf71f4efcc3fe99~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211014184339051"></p></li></ul> <p><em>[使用 <code>ffmpeg</code> 将 <code>gif</code> 转成 <code>MP4</code> 后的性能优化]</em></p> <h4 id="网络字体是否经过优化？"><a href="#网络字体是否经过优化？" class="header-anchor">#</a> 网络字体是否经过优化？</h4> <p>很多时候，我们使用的字体包并不需要适配所有的文字，尤其是中文字体动不动 10M+ 大小的情况下。所以</p> <ul><li>如果条件允许，我们可以对字体进行<strong>子集化</strong>（可以采用<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmunter%2Fsubfont" title="https://github.com/munter/subfont" target="_blank" rel="noopener noreferrer">subfont<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来帮助我们对项目进行分析）</li> <li>使用<code>preload</code>来预加载字体</li> <li>如果有必要的话，将字体缓存在<code>Service Worker</code>中</li></ul> <h3 id="构建优化"><a href="#构建优化" class="header-anchor">#</a> 构建优化</h3> <h4 id="你正在使用-tree-shaking、scope-hoisting-和-code-splitting-吗？"><a href="#你正在使用-tree-shaking、scope-hoisting-和-code-splitting-吗？" class="header-anchor">#</a> 你正在使用 tree-shaking、scope hoisting 和 code-splitting 吗？</h4> <ul><li><p><strong>tree-shaking</strong> 是一种清理构建包中无用依赖的方法，它让构建结果只包含生产中实际使用的代码，并消除 <code>Webpack</code> 中未使用的引入。借助 <code>Webpack</code> 和 <code>Rollup</code>，我们还可以实现 <strong>scope hoisting</strong> ，这两个工具都可以检测到 <code>import</code> 链可以在哪个位置终止并转换为一个内联函数，而不破坏代码。借助 <code>Webpack</code>，我们还可以使用 <strong>JSON Tree Shaking</strong></p></li> <li><p><strong>code-spliting</strong> 是 <code>Webpack</code> 的另一个功能，可以把你的代码拆分为按需加载的<code>chunk</code>。并不是所有 <code>JavaScript</code> 都必须立即下载、解析和编译。一旦在代码中定义了分割点，<code>Webpack</code> 就可以处理依赖关系和输出文件。它可以让浏览器保持较小的初始下载量，并在应用程序请求时按需请求代码。</p></li> <li><p>考虑使用 <strong>preload-webpack-plugin</strong>，这个插件可以根据你代码的分隔方式，让浏览器使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 或 <code>&lt;link rel=&quot;prefetch&quot;&gt;</code> 对分隔的代码<code>chunk</code>进行预加载。<strong>Webpack 内联指令</strong>还可以对 <code>preload/prefetch</code> 进行一些控制（但是请注意<strong>优先级问题</strong>。）</p></li></ul> <h4 id="能否将-javascript-抽离到-web-worker？"><a href="#能否将-javascript-抽离到-web-worker？" class="header-anchor">#</a> 能否将 JavaScript 抽离到 Web Worker？</h4> <p>为了缩短可交互时间的耗时，最好将有繁重计算的 <code>JavaScript</code> 抽离到 <code>Web Worker</code> 中或通过 <code>Service Worker</code> 进行缓存。因为 <strong>DOM 操作是与 JavaScript 一起运行在主线程上</strong>。使用 <code>Web worker</code> 可以将这些昂贵的操作转移到后台其他线程上运行。可以通过 <code>Web Worker</code> 预先加载和存储一些数据，以便后续在需要时使用它。可以使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FGoogleChromeLabs%2Fcomlink" title="https://github.com/GoogleChromeLabs/comlink" target="_blank" rel="noopener noreferrer">Comlink<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来简化与 <code>Web Worker</code> 之间的通信。</p> <h4 id="能否将频繁执行的功能抽离到-webassembly"><a href="#能否将频繁执行的功能抽离到-webassembly" class="header-anchor">#</a> 能否将频繁执行的功能抽离到 WebAssembly?</h4> <p>我们可以<strong>将繁重的计算任务抽离</strong> 到 <code>WebAssembly</code>（<em>WASM</em>）执行，它是一种二进制指令格式，被设计为一种用高级语言（如 C / C ++ / Rust）编译的可移植的对象。而且大多数现代浏览器都已经支持了 <code>WebAssembly</code>，并且随着 <strong>JavaScript 和 WASM 之间的函数调用变得越来越快</strong>，这个方式会变得越来越可行。<code>WebAssembly</code> 的目的并不是替代 <code>JavaScript</code>，而是可以在你发现当 CPU 占用过高时作为 <code>JavaScript</code> 的补充<code>JavaScript</code> 更适合大多数 Web 应用程序，而 <code>WebAssembly</code> 最适合用于计算密集型 Web 应用程序，例如 Web 游戏。</p> <p>下面附上 <code>JavaScript</code> 及 <code>WebAssembly</code> 的处理过程对比：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9706295a8a244117b22a935357ce0672~tplv-k3u1fbpfcp-watermark.awebp" alt="05-01-diagram_now01.png"></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da903ec010f6413db12e4de59cbe6c0b~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211015112700280"></p> <h4 id="你有在-javascript-中使用-module-nomodule-模式吗？"><a href="#你有在-javascript-中使用-module-nomodule-模式吗？" class="header-anchor">#</a> 你有在 JavaScript 中使用 module/nomodule 模式吗？</h4> <p>我们只想通过网络发送必要的 <code>JavaScript</code>，但这意味着对这些资源的交付要更加专注和细致。<strong>module/nomodule</strong> 的思想是编译并提供两个单独的 <code>JavaScript</code> 包：“常规”构建的构建方式是，一个包含 <code>Babel</code> 转换和 <code>polyfills</code>，仅提供给实际需要它们的旧版浏览器，另一个包（相同功能）不包含 <code>Babel</code> 转换和 <code>polyfills</code>。</p> <p><code>JS module</code>（或者称作<code>ES module</code>，<code>ECMAScript module</code>）是一个主要的新特性，或者说是一系列新特性。你可能已经使用过第三方的模块加载系统。<code>CommonJs</code> 如 <code>nodeJs</code> 、 <code>AMD</code> 如 <code>requireJs</code> 等等。这些模块加载系统都有一个共同点：它们允许你执行导入导出操作。</p> <p>能够认识<code>type=module</code>语法的浏览器会忽略具有<code>nomodule</code>属性的<code>scripts</code>。也就是说，我们可以使用一些脚本服务于支持<code>module</code>语法的浏览器，同时提供一个<code>nomodule</code>的脚本用于哪些不支持<code>module</code>语法的浏览器，作为补救。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5372670af0024f7f8c10dc12e2c557e1~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211015113845674"></p> <blockquote><p>使用 <code>type=module</code> 构建的文件体积优化相比常规构建的文件减少 30% ~ 50%，而且还能期待下浏览器对新语法的性能优化。</p></blockquote> <h4 id="识别并删除未使用的-css-js"><a href="#识别并删除未使用的-css-js" class="header-anchor">#</a> 识别并删除未使用的 CSS / JS</h4> <p>Chrome 中的 <strong>CSS 和 JavaScript 代码覆盖率工具(Coverage)</strong> 可以让我们了解哪些代码已执行或应用，哪些未执行。我们可以启动一个覆盖率检查，然后查看覆盖率结果。一旦检测到未使用的代码，<strong>找出那些模块并使用 import() 延迟加载</strong>。然后重复代码覆盖率检查确认现在在初始化时加载代码有变少。</p> <p>你可以使用 <code>Puppeteer</code> 来收集代码覆盖率，<code>Puppeteer</code> 还有许多<strong>其他用法</strong>，例如<strong>在每次构建时监视未使用的 CSS</strong>。</p> <p>此外，<strong>purgecss</strong>，<strong>UnCSS</strong> 和 <strong>Helium</strong> 可以帮助你从 <code>CSS</code> 中删除未使用的样式。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72fd4ddff0c44e49a7424ac61543ccfa~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211015120017651"></p> <h4 id="修剪-javascript-包大小"><a href="#修剪-javascript-包大小" class="header-anchor">#</a> 修剪 JavaScript 包大小</h4> <p>将依赖包审核添加到日常的工作流程中。使用更小巧轻便的库替换你可能在几年前添加的一些大型的库，例如使用 <code>Day.js</code> 替换 <code>Moment.js</code></p> <p>使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fbundlephobia.com%2F" title="https://bundlephobia.com/" target="_blank" rel="noopener noreferrer">Bundlephobia<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 之类的工具可以帮助你了解添加一个 npm 包的代价。<strong>size-limit</strong> 不仅会包检查大小，还会展示 <code>JavaScript</code> 的执行时长。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76718f56f3954a37a0121ed678357c28~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211015133611523"></p> <h4 id="使用针对目标-javascript-引擎的优化。"><a href="#使用针对目标-javascript-引擎的优化。" class="header-anchor">#</a> 使用针对目标 JavaScript 引擎的优化。</h4> <p>看下哪些 <code>JavaScript</code> 引擎在你的用户群中占主导地位，然后探索对其进行优化的方法。例如，当针对 <code>Blink</code> 浏览器、<code>Node.js</code> 运行时和 <code>Electron</code> 中使用的 V8 进行优化时，可以使用<strong>脚本流</strong>来处理整体脚本。</p> <blockquote><p>脚本流优化了 <code>JavaScript</code> 文件的解析。以前版本的 <code>Chrome</code> 会用一种简单的方法，在开始解析脚本之前完整的下载脚本，但在下载完成前并没有充分利用 CPU。从 41 版本开始，<code>Chrome</code> 会在下载开始后立即在单独的线程上解析<strong>异步和延迟脚本</strong>。这意味着解析可以在下载完成后的几毫秒内完成，并使页面加载速度提高最高 10%。这对于大型脚本和慢速网络连接特别有效。</p></blockquote> <p>下载开始后，<strong>脚本流</strong>允许 <code>async</code> 或 <code>defer scripts</code> 在单独的后台线程上进行解析，因此在某些情况下，页面加载时间最多可缩短 10％。而且，<strong>在 header 中使用 script defer</strong>，可以使<strong>浏览器更早的发现资源</strong>，然后在后台线程解析它。</p> <p><strong>警告</strong>：<code>Opera Mini</code> <strong>不支持脚本延迟</strong>，因此，如果你的主要用户是使用 <code>Opera Mini</code>， <code>defer</code> 则将被忽略，从而导致渲染被阻塞，直到脚本执行完毕。</p> <h4 id="客户端渲染还是服务器端渲染"><a href="#客户端渲染还是服务器端渲染" class="header-anchor">#</a> 客户端渲染还是服务器端渲染?</h4> <p>使用客户端渲染还是服务端渲染？这都得由应用程序的性能来决定。最好的方法是设置某种<strong>渐进式引导</strong>：使用服务端渲染来快速获得第一个有意义的图形(<code>FCP</code>)，同时包括一些最小体积的必需的 <code>JavaScript</code>，尽量让可交互时间（<code>TTI</code>）紧挨着第一个有意义的图形的绘制。如果 <code>JavaScript</code> 执行在 <code>FCP</code> 之后太晚，浏览器会在解析、编译和执行后来执行的 <code>JavaScript</code> 时<strong>锁定主线程</strong>，从而削弱了<strong>网站或应用程序的交互性</strong>。</p> <p>为了避免这种情况，我们务必将函数的执行分解为单独的异步任务，并尽可能使用 <code>requestIdleCallback</code>。使用 <code>WebPack</code> 的动态<code>import()</code>支持，延迟加载部分 UI，避免在用户真正需要它们之前因为加载、解析和编译造成的成本消耗。</p> <p>进入可交互状态后，我们可以按需或在时间允许的情况下启动应用程序的非必需部分。不过框架通常没有面向开发者提供简单的优先级概念，因此，对于大多数库和框架而言，实现逐步启动并不容易。</p> <p>下面我们来分析下目前的几种渲染机制：</p> <ul><li><p><strong>完全客户端渲染 （CSR）</strong></p> <p>所有的逻辑、渲染、启动均在客户端上完成。结果通常是 <code>TTI</code> 和 <code>FCP</code> 之间的间隔加大。由于整个应用程序必须在客户端上启动才能呈现任何内容，因此应用程序感觉很比较呆滞。通常来说<strong>SSR 比 CSR 快</strong>。但是对于许多应用程序来说，<code>CSR</code> 是最常见的实现方式。</p> <p>附上传统 <code>CSR</code> 的链路图：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb80f25cea9d4aa79ed791a159068a18~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211031150627907"></p></li> <li><h5 id="完全服务器端渲染（ssr）"><a href="#完全服务器端渲染（ssr）" class="header-anchor">#</a> 完全服务器端渲染（SSR）</h5> <p>服务器呈现响应于导航，为服务器上的页面生成完整的 <code>HTML</code>。这样可以避免在客户端进行数据获取和模板化的其他往返过程，因为它是在浏览器获得响应之前进行处理的。</p> <p><code>FP</code> 和 <code>FCP</code> 的差距通常很小，在服务器上运行页面逻辑和呈现可以避免向客户端发送大量 <code>JavaScript</code>，这有助于实现快速的可交互时间（<code>TTI</code>）。而且可以将 <code>HTML</code> 以流式传输到浏览器并立即呈现页面。不过，我们需要花费更长的时间去做解析，导致第一个字节到达（<code>TTFB</code>）浏览器的时间加长，并且我们没有利用现代应用程序的响应式功能和其他丰富的功能。</p></li> <li><h5 id="静态站点生成（ssg）"><a href="#静态站点生成（ssg）" class="header-anchor">#</a> 静态站点生成（SSG）</h5> <p>静态网站生成类似于服务器端渲染，不过是在<strong>构建时</strong>而不是在<strong>请求时</strong>渲染页面。与服务器渲染不同，由于不必动态生成页面的 <code>HTML</code>，因此它还可以保持始终如一的快速到第一字节的时间(<code>TTFB</code>)。通常，静态呈现意味着提前为每个 <code>URL</code> 生成单独的 <code>HTML</code> 文件。借助预先生成的 <code>HTML</code> 响应，可以将静态渲染器部署到多个 <code>CDN</code>，以利用边缘缓存的优势。因此，我们可以快速显示页面，然后为后续页面提前获取 <code>SPA</code> 框架。但是这种方法只适用于页面生成不依赖于用户输入的场景。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce15fe1d76f745a88f08f4cad69062e7~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211107194256621"></p></li> <li><h5 id="带有-re-hydration-的服务端渲染（ssr-csr）"><a href="#带有-re-hydration-的服务端渲染（ssr-csr）" class="header-anchor">#</a> 带有 (Re)Hydration 的服务端渲染（SSR + CSR）</h5> <p><code>Hydration</code> 译为 <code>水合</code>。是不是一脸懵逼！说人话，<strong>对曾经渲染过的HTML进行重新渲染的过程称为水合。</strong></p> <p>导航请求（例如整页加载或重新加载）由服务器处理，服务器将应用程序呈现为 <code>HTML</code>，然后将 <code>JavaScript</code> 和用于呈现的数据嵌入到生成的文档中。理想状态下，就像服务端渲染一样可以得到快速的 <code>FCP</code> ，然后通过使用称为 <code>(Re)Hydration</code> 的技术在客户端上再次渲染来<code>修补</code> 。</p> <p>借助 <code>React</code>，我们可以<strong>在 Node 上</strong>使用 <code>ReactDOMServer</code> 模块，然后调用 <code>renderToString</code> 方法将顶级组件生成为静态 <code>HTML</code> 字符串。使用 <code>Vue</code> 的话，我们可以使用 <strong>vue-server-renderer</strong> ，调用 <code>renderToString</code> 方法来将 <code>Vue</code> 实例渲染为 <code>HTML</code>。</p> <p>该方法也有其缺点，我们确实保留了客户端的全部灵活性，同时提供了更快的服务器端渲染，但是 <code>FCP</code> 和 <code>TTI</code> 之间的间隔也越来越大，并且 <code>FID</code> 也增加了。<strong>Hydration 非常昂贵</strong>，带有水合的 <code>SSR</code> 页面通常看起来具有欺骗性，并且具有交互性，但是在执行客户端 <code>JS</code> 并附加事件处理程序之前，<strong>实际上无法响应输入</strong>。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82127ff3782549e8be8fc8bbcdf84ed3~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p> <blockquote><p>注意 <strong>bundle.js</strong> 仍然是全量的 CSR 代码，这些代码执行完毕页面才真正可交互。因此，这种模式下，<strong>FP（First Paint）</strong> 虽然有所提升，但 <strong>TTI（Time To Interactive）</strong> 可能会变慢，因为在客户端二次渲染完成之前，页面无法响应用户输入（被 JS 代码执行阻塞了）</p> <p>对于二次渲染造成交互无法响应的问题，可能的优化方向是增量渲染（例如 <code>React Fiber</code>），以及渐进式渲染/部分渲染</p></blockquote></li> <li><h5 id="使用渐进-re-hydration-进行流式服务端渲染（ssr-csr）"><a href="#使用渐进-re-hydration-进行流式服务端渲染（ssr-csr）" class="header-anchor">#</a> 使用渐进 (Re)Hydration 进行流式服务端渲染（SSR + CSR）</h5> <p>为了最大程度地缩短 <code>TTI</code> 与 <code>FCP</code> 之间的间隔，我们可以发起多个请求，并在生成内容时分批发送内容（返回的响应体是<strong>流</strong>）。因此，在将内容发送到浏览器之前，我们不必等待完整的 <code>HTML</code> 字符串，还可以缩短第一个字节的时间（<code>TTFB</code>）。</p> <p>在 <code>React</code> 中，我们可以使用 <strong>renderToNodeStream</strong> 而不是 <code>renderToString</code> 来通过管道返回响应并将 <code>HTML</code> 分块发送。在 <code>Vue</code> 中，我们可以使用 <strong>renderToStream</strong> 来实现管道和流传输。随着 <code>React Suspense</code> 的到来，我们也可以使用<strong>异步渲染</strong>来达到相同目的。</p> <p>在客户端，我们不是一下启动整个应用程序，而是逐步启动组件。首先将应用程序的各个部分分解功能放到独立脚本中，然后逐步 <strong>“激活”</strong> （按优先级顺序）。我们可以先将关键组件激活，而其余的则随后激活。然后，可以针对每个组件定义为客户端还是服务器端渲染。然后，我们还可以延迟某些组件的激活，直到它们出现在可视区域或用户交互需要或浏览器处于空闲状态时。</p> <p>对于 <code>Vue</code>，当<strong>在用户交互时使用 hydration</strong> 或使用 <strong>vue-lazy-hydration</strong>（可以定义组件可见的时机或特定用户交互时激活组件）可以减少 <code>SSR</code> 应用程序的交互时间。你也可以<strong>使用 Preact 和 Next.js 实现部分 hydration</strong>。</p> <p>理想中的流式服务端渲染流程如下：</p> <ol><li>请求 <code>HTML</code>，服务器先返回骨架屏的 <code>HTML</code>，之后再返回所需数据，或者带有数据的 <code>HTML</code>，最后关闭请求。</li> <li>请求 <code>js</code>，<code>js</code> 返回并执行后就可以交互了。</li></ol> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ffd84452cd1470eba502077a1c767ee~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211031151026287"></p></li> <li><p><strong>客户端预渲染</strong></p> <p>与服务端预渲染相似，但不是在服务器上动态渲染页面，而是在构建时就将应用程序渲染为静态 <code>HTML</code>。</p> <p>在构建过程中使用 <code>renderToStaticMarkup</code> 方法而不是 <code>renderToString</code> 方法，生成一个没有 <code>data-reactid</code> 之类属性的静态页面，这个页面的主 <code>JS</code> 和后续可能会用到的路由会做预加载。也就是说，当初打包时页面是怎么样，那么预渲染就是什么样。等到 <code>JS</code> 下载并完成执行，如果页面上有数据更新，那么页面会再次渲染。这时会造成一种数据延迟的错觉。</p> <p>结果是 <code>TTFB（第一字节到达时间）</code> 和 <code>FCP</code> 时间变少，并且缩短了 <code>TTI</code> 和 <code>FCP</code> 之间的间隔。如果预期内容会发生很大变化，那么就无法使用该方法。另外，必须提前知道所有 <code>URL</code> 才能生成所有页面。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f3ffdc69699408f8d68dacaf67ec392~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20191231113759430"></p></li> <li><h5 id="三方同构渲染"><a href="#三方同构渲染" class="header-anchor">#</a> 三方同构渲染</h5> <p>如果可以使用 <code>Service Worker</code>，三方同构渲染也可能派上用场。这个技术是指：利用流式服务器渲染初始页面，等 <code>Service Worker</code> 加载后，接管 <code>HTML</code> 的渲染工作。这样可以让缓存的组件和模板保持最新，还可以启用像单页应用一样的导航用以在同一会话中预渲染新视图。当可以在服务器、客户端页面和 <code>Service Worker</code> 之间共享相同模板和路由代码时，此方法最有效。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38e587430c464061b84d49edcfb93971~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211024170611954"></p></li></ul> <blockquote><p>三方同构渲染，在三个位置使用相同的代码渲染：在服务器上，在 DOM 中或在 service worker 中。</p></blockquote> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0b9333d787a46e994d5cc99990467fe~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211024170857785"></p> <blockquote><p>服务端渲染到客户端渲染的技术频谱。</p></blockquote> <p>至于如何选择， 这里也给出一些不成熟的建议：</p> <ol><li>对 <code>SEO</code> 要求不高，同时<code>对操作需求比较多</code>的项目，比如一些管理后台系统，建议使用 <code>CSR</code>。因为只有在执行完 <code>bundle</code> 之后， 页面才能交互，单纯能看到元素，却不能交互， 意义不大，而且 <code>SSR</code> 会带来额外的开发和维护成本。</li> <li>如果页面<code>无数据</code>，或者是<code>纯静态</code>页面，建议使用 <code>SSG</code>。 因为这是一种通过预览打包的方式构建页面，也不会增加服务器负担。</li> <li>对 <code>SEO</code> 有比较大需求同时页面数据请求多的情况，建议使用 <code>SSR</code>。</li></ol> <h4 id="正确设置http缓存报文头"><a href="#正确设置http缓存报文头" class="header-anchor">#</a> 正确设置HTTP缓存报文头</h4> <p>仔细检查 <code>expires</code>、<code>max-age</code>、<code>cache-control</code> 和其他 <code>HTTP</code> 缓存报文头是否已正确设置。一般来说，资源可以在<strong>很短的时间内或无限期</strong>缓存，并且可以在需要时通过 URL 中更改其版本。</p> <p>使用<code>Cache-control: immutable</code>，用于表示响应正文<strong>不会随时间变化</strong>。资源如果未过期，在服务器上不会改变，因此浏览器不会发送缓存验证（例如：<code>If-None-Match</code>或<code>If-Modified-Since</code>）来检查更新，即便是用户刷新了页面。</p> <p>我们可以使用<code>Cache-Control</code>响应头指定了缓存时间，例如 <code>Cache-Control: max-age=60</code>。经过 60秒后，浏览器就会重新去获取资源，但是这会导致页面加载速度变慢。所以我们可以通过使用 <code>stale-while-revalidate</code> 来避免这种问题；例如：<code>Cache-Control: max-age=60, stale-while-revalidate=3600</code> 是说，这个缓存在 60 秒内是「新鲜」的，从 60 秒到 3660 秒的这一个小时内，虽然缓存是过期了，但仍可以直接使用这个过期缓存，同时进行异步更新，在 3660 秒之后，就是完全过期了，那么需要进行传统的同步资源获取了。</p> <p>在2019年6月至7月，<code>Chrome</code> 和 <code>Firefox</code> 开始对 <code>HTTP Cache-Control stale-while-revalidate</code> 支持，由于过期的资产不会再堵塞渲染，所以它可以提高后续的页面加载速度。效果：<strong>对于重连的视图，RTT 为零</strong>。</p> <blockquote><p>RTT：即是 Round Trip Time 的缩写，通俗点说，就是通信一来一回的时间。</p></blockquote> <p>此外，确保没有发送<strong>不必要的报头</strong>（例如 <code>x-powered-by</code>，<code>pragma</code>，<code>x-ua-compatible</code>，<code>expires</code>等）和确保报文中包含<strong>有用的安全和性能相关报文头</strong>（如 <code>Content-Security-Policy</code>，<code>X-XSS-Protection</code>，<code>X-Content-Type-Options</code> 等）。最后，请注意单页应用程序中 <strong>CORS 请求的性能成本</strong>。</p> <h3 id="传输优化"><a href="#传输优化" class="header-anchor">#</a> 传输优化</h3> <h4 id="是否对-javascript-库进行了异步加载？"><a href="#是否对-javascript-库进行了异步加载？" class="header-anchor">#</a> 是否对 JavaScript 库进行了异步加载？</h4> <p>当用户请求一个页面时，浏览器获取 <code>HTML</code> 构造 <code>DOM</code>，获取 <code>CSS</code> 构造 <code>CSSOM</code>，然后通过匹配 <code>DOM</code> 和 <code>CSSOM</code> 生成一个渲染树。但是只要需要解析 <code>JavaScript</code> 时，浏览器就会延迟渲染页面的时间。所以作为开发人员，我们必须明确地告诉浏览器立即开始渲染页面。可以通过给脚本添加 <code>HTML</code> 中的 <code>defer</code> 和 <code>async</code> 属性。</p> <p>然而，我们应该选用 <code>defer</code>，慎用 <code>async</code>。使用 <code>async</code> 的脚本一旦获取到，就会立即执行。假如这个 <code>async</code> 脚本获取的非常快，当脚本处于缓存就绪状态时，它实际上会阻塞 <code>HTML</code> 渲染。使用 <code>defer</code>，浏览器在解析 <code>HTML</code> 之前不会执行脚本。因此，除非在开始渲染之前需要执行 <code>JavaScript</code>，否则最好都使用 <code>defer</code>。</p> <p>另外，要限制第三方库和脚本的影响，特别要注意：例如社交分享按钮 <code>SDK</code> 和 <code>iframe</code> 标签（如地图）的使用。可以使用 <strong>size-limit 库</strong>防止 <code>JavaScript</code> 库膨胀：如果不小心添加了一个大的依赖项，这个工具将通知你并抛出一个错误。</p> <h4 id="使用-intersectionobserver-和图片懒加载"><a href="#使用-intersectionobserver-和图片懒加载" class="header-anchor">#</a> 使用 IntersectionObserver 和图片懒加载</h4> <p>一般来说，我们应该把所有耗性能的组件都做延迟加载，比如大的 <code>JavaScript</code>、视频、<code>iframe</code>、小组件和潜在的要加载的图片。例如：<strong>Native lazy-loading</strong> 可以帮助我们延迟加载图片和 <code>iframe</code>。</p> <blockquote><p><code>Native lazy-loading</code> 就是浏览器的 <code>img</code> 标签和 <code>iframe</code> 标签支持原生懒加载特性，使用<code>loading=&quot;lazy&quot;</code>语法标记即可。</p> <p>根据测试：需要在 <code>img</code> 标签中显形设置 <code>width</code> 和 <code>height</code> 才会支持延迟加载。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1842502a5b04db9a14d415a2a43f4cb~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211101131403567"></p></blockquote> <p>延迟加载脚本的最有效方式是使用 <strong>Intersection Observer API</strong>，这个 <code>API</code> 可以异步观察目标元素与祖先元素或文档的 <code>viewport</code> 之间交集的变化。我们需要创建一个 <code>IntersectionObserver</code> 对象，它接收一个回调函数和相应的参数，然后我们添加一个观察目标。如下</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>    <span class="token keyword">let</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>
      root<span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#scrollArea'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      rootMargin<span class="token operator">:</span> <span class="token string">'0px'</span><span class="token punctuation">,</span>
      threshold<span class="token operator">:</span> <span class="token number">1.0</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">let</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">let</span> target <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#listItem'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// threshold = 1.0 意味着 target 元素完全出现在 root 选项指定的元素中可见时，回调函数将会被执行。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>当目标变成可见或不可见时，回调函数就会执行，所以当它和 <code>viewport</code> 相交时，我们可以在元素变得可见之前执行一些操作。所以，我们可以通过 <code>rootMargin</code>（围绕根的边距）和 <code>threshold</code> （一个数字或一组数字，表示目标的可见性的百分比）对何时调用观察者的回调进行细粒度控制。</p> <h4 id="渐进加载图片"><a href="#渐进加载图片" class="header-anchor">#</a> 渐进加载图片</h4> <p>我们可以通过在页面中使用<strong>渐进式图片加载</strong>将延迟加载效果提升到新的高度。与 <strong>Facebook</strong>、<strong>Pinterest</strong> 和 <strong>Medium</strong> 类似，我们可以先加载低质量甚至模糊的图片，然后随着页面继续加载，使用 <strong>LQIP（低质量图片占位符）技术</strong>将它们替换为高质量的完整版本。</p> <p>配合懒加载，我们可以使用现成的库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FApoorvSaxena%2Flozad.js" title="https://github.com/ApoorvSaxena/lozad.js" target="_blank" rel="noopener noreferrer">lozad.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><em>给个最简单的演示代码:</em></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>    <span class="token operator">&lt;</span>img data<span class="token operator">-</span>src<span class="token operator">=</span><span class="token string">&quot;https://assets.imgix.net/unsplash/jellyfish.jpg?w=800&amp;h=400&amp;fit=crop&amp;crop=entropy&quot;</span>
              src<span class="token operator">=</span><span class="token string">&quot;https://assets.imgix.net/unsplash/jellyfish.jpg?w=800&amp;h=400&amp;fit=crop&amp;crop=entropy&amp;px=16&amp;blur=200&amp;fm=webp&quot;</span>
    <span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
        <span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> imgDefer <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>imgDefer<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>imgDefer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'data-src'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    imgDefer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">,</span>imgDefer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'data-src'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        window<span class="token punctuation">.</span>onload <span class="token operator">=</span> init<span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="你发送了关键-css-吗？"><a href="#你发送了关键-css-吗？" class="header-anchor">#</a> 你发送了关键 CSS 吗？</h4> <p>为了确保浏览器尽快开始渲染页面，只包含首屏渲染可见部分所需的所有 <code>CSS</code> 称为&quot;<strong>关键 CSS</strong>&quot;。将它内联在页面的 <code>&lt;head&gt;</code> 标签中，从而减少往返请求传输。由于在<strong>慢启动阶段</strong> <code>TCP</code> 交换的包的大小有限，所以关键 <code>CSS</code> 的大小应该不超过<strong>14KB</strong>。(这个特定的限制不适用于 <code>TCP BBR</code>，但是优先处理关键资源并尽早的去加载它们总是不会错的)。如果超出这个限制范围，浏览器将需要额外的传输往返用于获取更多样式。</p> <blockquote><p><em>这里简单介绍下上面说道的<strong>慢启动</strong> 和 <strong>TCP BBR</strong> ，顺带简述下 TCP 的几种避免拥塞的算法</em></p> <p>最初的TCP的实现方式是，在连接建立成功后便会向网络中发送大尺寸的数据包，假如网络出现问题，很多这样的大包会积攒在路由器上，很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此现在的TCP协议规定了，新建立的连接不能够一开始就发送大尺寸的数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量（最后到达一个稳定的值，进入高速传输阶段。相应的，慢启动过程中，TCP通道处在低速传输阶段），以避免上述现象的发生。这个策略就是<strong>慢启动</strong>。</p> <ol><li>慢启动算法</li></ol> <p>慢启动算法的思想是为发送方增加了一个<strong>拥塞窗口（Congestion Window）</strong>，记为 <strong>cwnd</strong>。</p> <p>拥塞窗口指的是在收到对端的ACK时还能发送的最大MSS（<em>最大报文段大小</em>）数。拥塞窗口是发送端维护的一个值，不会像接收方窗口（rwnd）那样通告给对端，<strong>发送方窗口的大小是 cwnd 和 rwnd 的最小值</strong>。目前的linux的拥塞窗口初始值为10个MSS。</p> <p>慢启动算法，每经过一个 RTT，cwnd 变为之前的两倍。发送方开始时发送 initcwnd 个报文段（<em>假设接收方窗口没有限制</em>）然后等待 ACK（<em>即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。</em>）。当收到该ACK时，拥塞窗口扩大为<code>initcwnd*2</code>，即可以发送<code>initcwnd*2</code>个报文段。当收到这发出报文段的 ACK 时，拥塞窗口继续扩大为<code>initcwnd*4</code>,这是一种指数增加的关系。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63230630bb2c43428ef82ba6c72cbe1f~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211102150656462"></p> <ol start="2"><li>拥塞避免算法</li></ol> <p>拥塞避免算法和慢启动算法是两个不同的算法，但是他们都是为了解决拥塞，在实际中这两个算法通常是在一起实现的。相比于慢启动算法，拥塞避免算法多维护了一个<strong>慢启动阈值ssthresh</strong>。</p> <p>当 cwnd &lt; ssthresh 时，拥塞窗口使用慢启动算法，按指数级增长。 当 cwnd &gt; ssthresh 时，拥塞窗口使用拥塞避免算法，按线性增长。</p> <p>拥塞避免算法每经过一个RTT，拥塞窗口增加<code>initcwnd</code>。</p> <p>当发生拥塞的时候（超时或者收到重复ack），RFC5681 认为此时 ssthresh 需要置为没有被确认包的一半，但是不小于两个MSS。此外，<strong>如果是超时引起的拥塞，则 cwnd 被置为 initcwnd</strong>。</p> <p><strong>超时重传对传输性能有严重影响。原因：一、在RTO(<em>重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。</em>)阶段不能传数据，相当于浪费了一段时间；二、拥塞窗口的急剧减小，相当于接下来传得慢多了。</strong></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df25dda7388b43ed89d5f12624001be1~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211102152618349"></p> <ol start="3"><li>快重传算法</li></ol> <p>有时候拥塞比较轻微，只有少量包丢失，后续的包能够正常到达。当后续的包到达接收方时，接收方会发现其 Seq 号比期望的大，所以它每收到一个包就 Ack 一次期望的 Seq 号，以此提醒发送方重传。当发送方收到<strong>3个或以上</strong>重复确认（Dup Ack）时，就意识到相应的包已经丢了，从而立即重传它。这个过程称为快速重传。</p> <p>为什么要规定凑满3个呢？这是因为网络包有时会乱序，乱序的包一样会触发重复的 Ack，但是为了乱序而重传没有必要。由于一般乱序的距离不会相差太大，比如2号包也许会跑到4号包后面，但不太可能跑到6号包后面，所以限定成3个或以上可以在很大程度上避免因乱序而触发快速重传。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd3805055dc74bec9169d6cdde9aab46~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211102153509995"></p> <p>另外还有一个问题，如果我们2和3号包都丢了，但是后面4、5、6、7号都正常收到了，并触发了三次 ACK 2。这时候发送端端如果收到多个重复的ACK，认为发生丢包，TCP会重传最后确认的包开始的后续包。这样原先已经正确传输的包可能会重复发送，降低了TCP性能。为改善这种情况，发展出SACK（<em>选择性确认</em>）技术，使用 SACK 选项可以告知发包方收到了哪些数据，发包方收到这些信息后就会知道哪些数据丢失，然后立即重传丢失的部分。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30d765744a7f40a1ad5006e1a9ff0423~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211102154345754"></p> <ol start="4"><li>快恢复算法</li></ol> <p>如果在拥塞阶段发生了快速重传就没有必要像超时重传那样处理拥塞窗口了，考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。这个过程被称为<strong>快恢复</strong>。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ac784a69ce842bab4f2a511602e3e19~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211102162546985"></p> <p>总结：</p> <ul><li><p><strong>超时重传对性能的影响最大，因为在RTO期间不能传输任何数据，而且拥塞窗口会急剧减小。所以应该尽量避免超时重传。</strong></p></li> <li><p><strong>丢包对极小文件的影响比大文件严重，因为小文件可能不能触发三次重复的Ack，导致无法快速重传。</strong></p></li> <li><p><strong>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。</strong></p></li></ul></blockquote> <blockquote><p>TCP BBR 是由 Google 发表的新的 TCP 拥塞控制算法，目前已经在 Google 内部大范围使用并且随着 linux 4.9 版本正式发布。</p> <p>BBR 的名称实际上是 bottleneck bandwith and round-trip propagation time (瓶颈带宽和往返传播时间) 的首字母缩写，表明了 BBR 的主要运行机制：<strong>通过检测带宽和RTT这两个指标来进行拥塞控制。</strong> BBR 算法的主要特点有以下几个：</p> <ol><li>BBR 不考虑丢包，因为丢包（在现在这个时代）并不一定是网络出现拥塞的标志了</li> <li>BBR 依赖实时检测的带宽和 RTT 来决定拥塞窗口的大小：窗口大小 = 带宽 * RTT</li></ol></blockquote> <h4 id="尝试重新组合你的-css-规则"><a href="#尝试重新组合你的-css-规则" class="header-anchor">#</a> 尝试重新组合你的 CSS 规则</h4> <p>根据<a href="https://link.juejin.cn?target=https%3A%2F%2Fcsswizardry.com%2F2018%2F11%2Fcss-and-network-performance%2F" title="https://csswizardry.com/2018/11/css-and-network-performance/" target="_blank" rel="noopener noreferrer">CSS and Network Performance<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的研究，按照媒体查询条件把 <code>CSS</code> 文件进行拆分可能对我们的页面性能有一定提升。这样，浏览器会使用高优先级检索关键CSS，使用低优先级处理其他的所有内容。</p> <p>例如：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">&quot;stylesheet&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;all.css&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>我们把所有的css放在一个文件中，浏览器会这样处理他：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0f042f3aba640029d684db0f1ca532f~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211102164235989"></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">&quot;stylesheet&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;all.css&quot;</span> media<span class="token operator">=</span><span class="token string">&quot;all&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">&quot;stylesheet&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;small.css&quot;</span> media<span class="token operator">=</span><span class="token string">&quot;(min-width: 20em)&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">&quot;stylesheet&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;medium.css&quot;</span> media<span class="token operator">=</span><span class="token string">&quot;(min-width: 64em)&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">&quot;stylesheet&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;large.css&quot;</span> media<span class="token operator">=</span><span class="token string">&quot;(min-width: 90em)&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">&quot;stylesheet&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;extra-large.css&quot;</span> media<span class="token operator">=</span><span class="token string">&quot;(min-width: 120em)&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">&quot;stylesheet&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;print.css&quot;</span> media<span class="token operator">=</span><span class="token string">&quot;print&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>当我们将其拆分成按 <code>media</code> 查询的时候，浏览器会这样：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a000657af26e4acb90901a2ef499b706~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211102164307446"></p> <p>避免在 CSS 文件中使用 <code>@import</code>，因为它的工作原理，会影响浏览器的并行下载。不过目前我们更多使用的是 <code>scss</code>、<code>less</code>他们会将 <code>@import</code> 的文件直接包含在 <code>CSS</code> 中，并不会产生额外的 <code>HTTP</code> 请求。</p> <p>另外，不要将 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 放在 <code>async</code> 代码段之前。如果 <code>JavaScript</code> 脚本不依赖于样式，可以考虑将异步脚本置于样式之上。如果存在依赖，可以将 <code>JavaScript</code> 分成两部分，将它们分别放到 <code>CSS</code> 的两边来加载。</p> <p><strong>动态样式也可能会有很高的代价</strong>，虽然因为 <code>React</code> 的性能很好，所以通常只会发生在大量组合组件并行渲染时才会出现这种情况。根据 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcalendar.perfplanet.com%2F2019%2Fthe-unseen-performance-costs-of-css-in-js-in-react-apps%2F" title="https://calendar.perfplanet.com/2019/the-unseen-performance-costs-of-css-in-js-in-react-apps/" target="_blank" rel="noopener noreferrer">The unseen performance costs of modern CSS-in-JS libraries in React apps<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的研究，在 <code>production</code> 模式开启时，通过 <code>CSS-in-JS</code> 创建的组件可能会比常规的 <code>React</code> 组件多花一倍的渲染时间。所以在应用 <code>CSS-in-JS</code> 时，可以采用以下方案来提升你的程序性能：</p> <ol><li><strong>不要过度的组合嵌套样式组件</strong>：这可以让 <code>React</code> 需要管理的组件更少，可以更快的完成渲染工作</li> <li><strong>优先使用“静态”组件</strong>：一些 <code>CSS-in-JS</code> 库会在你的 <code>CSS</code> 没有依赖主题或 <code>props</code> 的情况下优化其执行。你的标签模板越是 「静态」，你的 <code>CSS-in-JS</code> 运行时就越有可能执行得更快。</li> <li><strong>避免无效的React重新渲染</strong>：确保只在需要的时候才渲染，这样可以避免 <code>React</code> 和 <code>CSS-in-JS</code> 库的运行时工作。</li> <li><strong>零运行时的 CSS-in-JS 库是否能适用于你的项目</strong>：有时我们会选择在 <code>JS</code> 中编写 <code>CSS</code>，因为它确实提供了一些很好的开发者体验，同时我们又不需要访问额外的<code>JS API</code>。如果你的应用程序不需要对主题的支持，也不需要使用大量复杂的 <code>CSS props</code>，那么零运行时的 <code>CSS-in-JS</code> 库可能是一个很好的选择。使用零运行时的库，你能从你的 <code>bundle</code> 文件中减少 12KB，因为大多数 <code>CSS-in-JS</code> 库的大小在 10KB-15KB 之间，而零运行时的库（如 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcallstack%2Flinaria" title="https://github.com/callstack/linaria" target="_blank" rel="noopener noreferrer">linaria<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）小于1KB。</li></ol> <h4 id="预热连接用于加速传输"><a href="#预热连接用于加速传输" class="header-anchor">#</a> 预热连接用于加速传输</h4> <p>使用 <strong>资源提示（resource hint）</strong> 节省时间：</p> <p><code>dns-prefetch</code>： 提示浏览器该资源需要在用户点击链接之前进行 DNS 查询和协议握手。</p> <p><code>preconnect</code>： 向浏览器提供提示，建议浏览器提前打开与链接网站的连接，而不会泄露任何私人信息或下载任何内容，以便在跟随链接时可以更快地获取链接内容。</p> <p><code>prefetch</code>： 提示浏览器，用户未来的浏览有可能需要加载目标资源，所以浏览器有可能通过事先获取和缓存对应资源，优化用户体验。</p> <p><code>preload</code>： 告诉浏览器下载资源，因为在当前导航期间稍后将需要该资源。</p> <p>然后发现这里是不是还少了个 <code>prerender</code>？（建议浏览器事先获取链接的资源，并建议将预取的内容显示在屏幕外，以便在需要时可以将其快速呈现给用户。）</p> <p>但是在实际中使用是它确很困难。因为它会使浏览器除了去获取资源，还可能会预处理该资源，而该 <code>HTML</code> 页面依赖的其他资源，像<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 等页面所需资源也可能会被处理。预处理会由于浏览器或当前机器、网络情况的不同而被不同程度地推迟。例如，会根据 CPU、GPU 和内存的使用情况，以及请求操作的幂等性而选择不同的策略或阻止该操作。</p> <p>所以，不出所料，它被弃用了。但 <code>Chrome</code> 团队基于此提出了 <strong>NoState Prefetch 机制</strong>。在 Chrome 63 版本以上，<code>Chrome</code> 已经把 <code>prerender</code> 当作了一个 <code>NoState Prefetch</code>，它的表现就像 <code>prerender</code> 一样，<code>NoState Prefetch</code> 会提前获取资源；但与 <code>prerender</code> 不同的是，它不执行 <code>JavaScript</code>，也不提前渲染页面的任何部分。<code>NoState Prefetch</code> 只使用约 45MiB 的内存，且子资源处理的优先级只是 <code>空闲（IDLE）</code> 级别。从 Chrome 69 开始，<code>NoState Prefetch</code> 就在所有的请求中加入了请求头 <code>Purpose: Prefetch</code>，以便它们区别于普通的浏览。</p> <p>实际上，我们至少会使用 <code>preconnect</code> 和 <code>dns-prefetch</code>，会谨慎使用 <code>prefetch</code>, <code>preload</code> 和 <code>prerender</code>。需要注意的是：只有在你确认用户下一步将需要什么资源（例如：购买流程，注册流程）时，才应该使用 <code>prerender</code>。</p> <p>即使使用了 <code>preconnect</code> 和 <code>dns-prefetch</code>，浏览器也会限制并行连接的主机数量，所以，根据优先级对它们进行排序会更好。</p> <p>使用 <code>resource hint</code> 可能是提高性能的最简单的方法，而且它确实能给你带来性能提升。</p> <p>下面附上各个阶段资源的请求优先级对照表：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/398ea9cb1a2f4b31861993a077cd2c1e~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p> <p>由于字体文件一般是页面上的重要资源，有时通过 <code>preload</code> 提示浏览器下载重要字体是一个比较好的方法。但是，需要仔细看下这样做是否真的能提升性能，因为<strong>在预加载字体时存在一个优先级的难题</strong>：由于预加载被视为非常重要，它可以跳过甚至更关键的资源，如关键 CSS。</p> <p>您还可以<strong>动态加载 JavaScript</strong>，有效地延迟加载执行。此外，由于 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 接受 <code>media</code> 属性，所以可以根据 <code>@media</code> 查询规则<strong>选择性的对资源进行优先级排序</strong>。</p> <p>最后，<strong>有几个需要注意的问题</strong>：</p> <p><code>preload</code> 有助于将<strong>资源的开始下载时间</strong>提前到更接近初始请求的时间，但是预加载资源会占用与页面的内存缓存。</p> <p><code>preload</code> 可以很好地处理 <code>HTTP</code> 缓存：如果资源已经在 <code>HTTP</code> 缓存中，则永远不会发送网络请求。</p> <p>因此，<code>preload</code> 对于后续触发加载的资源，如 <code>background-image</code> 加载的图片、内联关键的 CSS（或 <code>JavaScript</code>）并预加载其余的 CSS（或 <code>JavaScript</code>）非常有用。此外，只有在浏览器从服务器接收到 <code>HTML</code> 并且解析器找到 <code>preload</code> 标记之后，<code>preload</code> 标记才能初始化预加载。</p> <p>另外还有一些新的提案，例如：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FStatus%2F103" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/103" target="_blank" rel="noopener noreferrer">Early Hint<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 可以在 <code>HTML</code> 的响应头之前，就可以启用 <code>preload</code>，<strong>Priority Hints</strong> 为开发人员提供了一种向浏览器表明资源优先级的方法，允许我们更好的控制资源加载的顺序。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56e8e33e4b93481f9722c431c7c06680~tplv-k3u1fbpfcp-watermark.awebp" alt="Nov-02-2021 20-25-58"></p> <blockquote><p>注意：如果你正在使用 <code>preload</code>，必须定义 <code>as</code>，否则不会加载；不带 <code>crossorigin</code> 属性的预加载字体会被重复获取。</p></blockquote> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">&quot;preload&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;style.css&quot;</span> <span class="token keyword">as</span><span class="token operator">=</span><span class="token string">&quot;style&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">&quot;preload&quot;</span> href<span class="token operator">=</span><span class="token string">&quot;main.js&quot;</span> <span class="token keyword">as</span><span class="token operator">=</span><span class="token string">&quot;script&quot;</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="优化渲染性能"><a href="#优化渲染性能" class="header-anchor">#</a> 优化渲染性能</h4> <p>使用 <code>CSS</code> 的 <strong>will-change</strong> 通知浏览器哪些元素和属性将会改变。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>    <span class="token property">will-change</span><span class="token punctuation">:</span> auto
    <span class="token property">will-change</span><span class="token punctuation">:</span> scroll-position
    <span class="token property">will-change</span><span class="token punctuation">:</span> contents
    <span class="token property">will-change</span><span class="token punctuation">:</span> transform
    <span class="token property">will-change</span><span class="token punctuation">:</span> opacity
    <span class="token property">will-change</span><span class="token punctuation">:</span> left<span class="token punctuation">,</span> top
    
    <span class="token property">will-change</span><span class="token punctuation">:</span> unset
    <span class="token property">will-change</span><span class="token punctuation">:</span> initial
    <span class="token property">will-change</span><span class="token punctuation">:</span> inherit
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>CSS</code> 大部分样式是通过 <code>CPU</code> 来计算的，但 <code>CSS</code> 中也有一些 3D 的样式和动画的样式，计算这些样式会有有很多重复且大量的计算任务，可以交给 <code>GPU</code> 来跑。</p> <p>浏览器在处理下面的 <code>CSS</code> 的时候，会使用 <code>GPU</code> 渲染：</p> <ul><li><code>transform</code></li> <li><code>opacity</code></li> <li><code>filter</code></li> <li><code>will-change</code></li></ul> <p>这里要注意的是 <code>GPU</code> 硬件加速是需要新建图层的，而把该元素移动到新图层是个耗时操作，界面可能会闪一下，所以最好提前做。<code>will-change</code> 就是提前告诉浏览器在一开始就把元素放到新的图层，方便后面用 <code>GPU</code> 渲染的时候，不需要做图层的新建。</p> <h4 id="你是否了解如何避免回流和重绘"><a href="#你是否了解如何避免回流和重绘" class="header-anchor">#</a> 你是否了解如何避免回流和重绘?</h4> <p>说道<strong>回流</strong>和<strong>重绘</strong>，我们先来回顾下浏览器的渲染流程：</p> <ol><li><p><strong>构建 DOM 树</strong></p> <ul><li><code>HMTL</code> 词法语法分析，转成对应的 <code>AST</code> 树</li></ul></li> <li><p><strong>样式计算</strong></p> <ul><li><p>格式化样式属性，例如：<code>rem</code> -&gt; <code>px</code>、<code>white</code> -&gt; <code>#FFFFFF</code> 等</p></li> <li><p>计算每个节点样式属性：根据 <code>CSS</code> 选择器与 <code>DOM 树</code>共同构建 <code>render 树</code></p></li></ul></li> <li><p><strong>生成布局树</strong></p> <ul><li>这里去除一些 <code>dispy:none</code> 等隐藏样式的元素，因为它们不在 <code>render</code> 树中</li></ul></li> <li><p><strong>建立图层树</strong></p> <ul><li>主要分为「显式合成」和「隐式合成」
<ul><li>当重绘时就只需要重绘当前图层</li></ul></li></ul></li> <li><p><strong>生成绘制列表</strong></p> <ul><li>将图层树转换成绘制的指令列表</li></ul></li> <li><p><strong>生成图块和位图</strong></p> <ul><li><p>绘制列表交付给合成线程，进行图层分块。</p></li> <li><p>渲染进程中专门维护了一个栅格化线程池，专门负责把图块交由 <code>GPU</code> 渲染</p></li> <li><p><code>GPU</code> 渲染后将位图信息传递给合成线程，合成线程将位图信息在显示器显示</p></li></ul></li> <li><p><strong>显示器显示内容</strong></p></li></ol> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95b9ec76b30441b5a09f44d7a48b4de8~tplv-k3u1fbpfcp-watermark.awebp" alt="图片描述"></p> <p>其中第四步<strong>建立图层树</strong>很重要，我们再着重的讲一下。浏览器从 <code>DOM 树</code>画质到屏幕图形上，需要做树结构到层结构的转化。这里介绍4个点：</p> <ol><li><p><strong>渲染对象（RenderObject）</strong></p> <p>一个 <code>DOM</code> 节点对应了一个渲染对象，渲染对象维持着 <code>DOM</code> 树的树形结构。渲染对象知道怎么去绘制 <code>DOM</code> 节点的内容，它通过向一个绘图上下文（GraphicsContext）发出必要的绘制指令来绘制 <code>DOM</code> 节点。</p></li> <li><p><strong>渲染层（RenderLayer）</strong></p> <p>浏览器渲染时第一个构建的层模型，位于同一个层级坐标空间的渲染对象都会被归并到同一个渲染层中，所以根据层叠上下文，不同层级坐标空间的的渲染对象将会形成多个渲染层，以此来体现它们之间的层叠关系。所以，对于满足形成层叠上下文条件的渲染对象，浏览器会自动为其创建新的渲染层。通常以下几种常见情况会让浏览器为其创建新的渲染层：</p> <ul><li><code>document</code> 元素</li> <li><code>position: relative | fixed | sticky | absolute</code></li> <li><code>opacity</code> &lt; 1</li> <li><code>will-change | fliter | mask | transform != none | overflow != visible</code></li></ul></li> <li><p><strong>图形层（GraphicsLayer）</strong></p> <p>图形层是一个负责生成最终准备呈现出来的内容图形的层模型，它拥有一个图形上下文（GraphicsContext），图形上下文会负责输出该层的位图。存储在共享内存中的位图将作为纹理（<em>可以把它想象成一个从主存储器移动到图像存储器的位图图像</em>）上传到 <code>GPU</code>，最后由 <code>GPU</code> 将多个位图进行合成，然后绘制到屏幕上，此时，我们的页面也就展现到了屏幕上。</p> <p>所以图形层是一个重要的渲染载体和工具，但它并不直接处理渲染层，而是处理合成层。</p></li> <li><p><strong>合成层（CompositingLayer）</strong></p> <p>满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的图形层，而其他不是合成层的渲染层，则会和第一个拥有图形层的父层共用一个。</p> <p>那么一个渲染层满足哪些特殊条件时，才能被提升为合成层呢？这里也列举一些常见情况：</p> <ul><li><code>3D transforms</code></li> <li><code>video</code>、<code>canvas</code>、<code>iframe</code></li> <li><code>opacity</code> 动画转换</li> <li><code>position: fixed</code></li> <li><code>will-change</code></li> <li><code>animation</code> 或 <code>transition</code> 设置了<code>opacity</code>、<code>transform</code>、<code>fliter</code>、<code>backdropfilter</code></li></ul></li></ol> <p>上面提到满足一些特殊条件的渲染层最终会被浏览器提升了合成层，称为<strong>显式合成</strong>。除此之外，浏览器在合成阶段还存在一种<strong>隐式合成</strong>。下面我们通过举例来看下：</p> <ul><li>假设，我们有两个 <code>absolute</code> 定位的 <code>div</code> 在屏幕上交叠了，根据 <code>z-index</code> 的关系，其中一个 <code>div</code> 就会”盖在“了另外一个上边。</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c5f2deba4b24ee8af7edd7704f2f989~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211104165440485"></p> <ul><li>这时候，如果我们给 <code>z-index: 3</code> 设置 <code>transform: translateZ(0)</code> ，让浏览器将其提升为<strong>合成层</strong>。提升后 <code>z-index: 3</code> 这个合成层就会在 <code>docuemnt</code> 上方，那么按理来说 <code>z-index: 3</code> 就会在 <code>z-index: 5</code> 上面，我们设置的 <code>z-index</code> 就会出现交叠关系错乱的情况</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8824272912d4414881b505afd76fa9d5~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211104165908499"></p> <ul><li>为了纠正这种错误的交叠顺序，浏览器必须让原本应该”盖在“它上边的渲染层也同时提升为合成层。这称为<strong>隐式合成</strong></li></ul> <p>渲染层提升为合成层之后，会给我们带来不少好处：</p> <ol><li>合成层的位图，会交由 <code>GPU</code> 合成，比 <code>CPU</code> 处理要快得多；</li> <li>当需要重绘时，只需要重绘本身，不会影响到其他的层；</li> <li>元素提升为合成层后，<code>transform</code> 和 <code>opacity</code> 才不会触发重绘，如果不是合成层，则其依然会触发重绘。</li></ol> <p>当然了，任何东西滥用都是会有副作用，例如：</p> <ol><li>绘制的图层必须传输到 <code>GPU</code>，这些层的数量和大小达到一定量级后，可能会导致传输非常慢，进而导致一些低端和中端设备上出现闪烁；</li> <li>隐式合成容易产生过量的合成层，每个合成层都占用额外的内存，形成<strong>层爆炸</strong>。占用 <code>GPU</code> 和大量的内存资源，严重损耗页面性能。而内存是移动设备上的宝贵资源，过多使用内存可能会导致浏览器崩溃，让性能优化适得其反。</li></ol> <p>OK，大概知道了浏览器的渲染原理后，我们来看下如何在实际中去减少回流和重绘：</p> <ol><li>始终在图像上<strong>设置宽度和高度属性</strong>：浏览器会在默认情况下会分配框并保留空间，后续图片资源加载完成后不需要回流。</li> <li>避免多次修改：例如我们需要修改一个 <code>DOM</code> 的 <code>height/width/margin</code> 三个属性，这时候我们可以通过 <code>cssText</code> 去修改，而不是通过 <code>dom.style.height</code> 去修改。</li> <li>批量修改 DOM：将 <code>DOM</code> 隐藏或者克隆出来修改后再替换，不过现在浏览器会用队列来存储多次修改，进行优化。 这个是适用范围已经不是那么广了。</li> <li>脱离文档流：对于一些类似动画之类的频繁变更的 <code>DOM</code>.可以使用绝对定位将其脱离文档流，避免父元素频繁回流。</li></ol> <h3 id="网络优化"><a href="#网络优化" class="header-anchor">#</a> 网络优化</h3> <h4 id="启用-ocsp-stapling-了吗？"><a href="#启用-ocsp-stapling-了吗？" class="header-anchor">#</a> 启用 OCSP stapling 了吗？</h4> <p>通过<strong>在服务器上启用 OCSP stapling</strong>，可以加快 <code>TLS</code> 握手的速度。「在线证书状态协议」（<code>OCSP</code>）是「证书吊销列表」（<code>CRL</code>）协议的替代品。两种协议都用于检查 <code>SSL</code> 证书是否已被吊销。但是，<code>OCSP</code> 协议不需要浏览器花时间下载和搜索证书信息列表，因此减少了握手所需的时间。</p> <blockquote><ul><li><p><strong>证书吊销列表（CRL）：</strong> CRL 分布在公共可用的存储库中，浏览器可以在验证证书时获取并查阅 CA 的最新 CRL。 该方法的一个缺陷是吊销列表的时间粒度受限于 CRL 发布期。只有在 CA 厂商更新所有当前发布的 CRL 之后，才会通知浏览器撤销。 各家签名 CA 厂商的策略不一样，有的是几小时，有的是几天，甚至几周。</p></li> <li><p><strong>在线证书状态协议（OCSP）</strong>：为了解决单个文件大，延迟性高等问题，迎来了新的解决方案 OCSP。浏览器从在线 OCSP 服务器（也称为OCSP Response Server）请求证书的撤销状态，OCSP Server予以响应。这种方法避免CRL更新延迟问题。该方法的缺点是：</p> <ol><li>浏览器的每次 HTTPS 请求创建，都需要连接 CA OCSP Server 进行验证，有的浏览器所在 IP 与 CA OCSP Server 的网络并不是通畅的。而且，OCSP 的验证有网络 IO，花费了很长的时间，严重影响了浏览器访问服务器的用户体验。</li> <li>在浏览器发送服务器 HTTPS 证书序号到 CA OCSP Server 时，也将暴露了用户的隐私，将用户访问的网址透漏给了 CA OCSP Server。</li></ol></li> <li><p><strong>OCSP装订（OCSP Stapling）</strong>：OCSP Stapling 解决了 CRL、OCSP 的缺点，将调用 OCSP Server 获取证书吊销状况的过程交给 Web 服务器来做，Web 服务器不光可以直接查询 OCSP 信息，规避<code>网络访问限制</code>、<code>OCSP服务器离用户的物理距离较远</code>等问题，还可以将查询响应缓存起来，给其他浏览器使用。由于 OCSP 的响应也是具备 CA RSA 私钥签名的，所以不用担心伪造问题。</p> <ol><li><p>解决了访问慢的问题</p></li> <li><p>解决了用户隐私泄露的问题</p></li></ol></li></ul></blockquote> <h4 id="是否针对http协议做了正确的优化？"><a href="#是否针对http协议做了正确的优化？" class="header-anchor">#</a> 是否针对HTTP协议做了正确的优化？</h4> <p>随着 <code>HTTPS</code> 及 <code>HTTP/2</code> 的流行，很多 <code>HTTP/1.1</code> 时代的优化策略已经不奏效了，甚至还有反优化的作用。</p> <p>这里我们顺带把各个版本的 <code>HTTP</code> 协议做一下简单的分析：</p> <ul><li><p><strong>HTTP/1.0</strong></p> <ul><li>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接（<strong>TCP连接的新建成本很高，因为需要客户端和服务器三次握手</strong>），服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求</li></ul></li> <li><p><strong>HTTP/1.1</strong></p> <ul><li><strong>管道化（Pipelining</strong>）：提出管道化方案解决连接延迟，服务端可设置 <code>Keep-Alive</code> 来让连接延迟关闭时间，但因为浏览器自身的 <code>Max-Connection</code> 最大连接限制，同一个域名下的请求连接限制（同域下谷歌浏览器是一次限制最多6个连接），只能通过多开域名来实现，这也就是我们的静态资源选择放到 <code>CDN</code> 上或其它域名下，来提高资源加载速度。管道化方案需要前后端支持，但绝大部分的<code>HTTP</code>代理器对管道化的支持并不友好。</li> <li><strong>只支持GET/HEAD</strong>：管道化只支持 <code>GET</code> / <code>HEAD</code>方式传送数据，不支持 <code>POST</code> 等其它方式传输。</li> <li><strong>头部信息冗余</strong>：<code>HTTP</code> 是无状态的，客户端/服务端只能通过 <code>HEAD</code> 的数据维护获取状态信息，这样就造成每次连接请求时都会携带大量冗余的头部信息，头部信息包括 <code>COOKIE</code> 信息等。</li> <li><strong>超文本协议</strong>：<code>HTTP/1.X</code> 是超文本协议传输。超文本协议传输，发送请求时会找出数据的开头和结尾帧的位置，并去除多余空格，选择最优方式传输。如果使用了 <code>HTTPS</code>，那么还会对数据进行加密处理，一定程度上会造成传输速度上的损耗。</li> <li><strong>队头阻塞</strong>:管道化通过延迟连接关闭的方案，虽然可同时发起对服务端的多个请求，但服务端的 <code>response</code> 依旧遵循<code>FIFO</code>（先进先出)规则依次返回。举个例子客户端发送了1、2、3、4四个请求，如果1没返回给客户端，那么2，3，4也不会返回。这就是所谓的「队头阻塞」。高并发高延迟的场景下阻塞明显。</li></ul></li> <li><p><strong>HTTP/2.0</strong></p> <ul><li><strong>多路复用</strong>：一个域只要一个 <code>TCP</code> 连接，实现真正的并发请求，降低延时，提高了带宽的利用率。</li> <li><strong>头部压缩</strong>：客户端/服务端进行渐进更新维护，采用 <code>HPACK</code> 压缩，节省了报文头占用流量。
<ol><li>相同的头部信息不会通过请求发送，延用之前请求携带的头部信息。</li> <li>新增/修改的头部信息会被加入到 <code>HEAD</code> 中，两端渐进更新。</li></ol></li> <li><strong>请求优先级</strong>：每个流都有自己的优先级别，客户端可指定优先级。并可以做流量控制。</li> <li><strong>服务端推送</strong>：例如我们加载 index.html, 我们可能还需要index.js, index.css等文件。传统的请求只有当拿到index.html，解析html中对index.js/index.css的引入才会再请求资源加载，但是通过服务端数据，可以提前将资源推送给客户端，这样客户端要用到的时候直接调用即可，不用再发送请求。</li> <li><strong>二进制协议</strong>：采用二进制协议，区别 <code>与HTTP/1.X的</code> 超文本协议。客户（服务）端发送（接收）数据时，会将数据打散乱序发送，接收数据时接收一端再通过 <code>streamID</code> 标识来将数据合并。二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。</li></ul> <blockquote><p>这里再补充一下 HTTP2 相对于 HTTP1.1 并不全是优点：因为 HTTP2 将多个 HTTP 流放在同一个 TCP 连接中，遵循同一个流量状态控制。只要第一个 HTTP 流遇到阻塞，那么后面的 HTTP 流压根没办法发出去，这就是「行头阻塞」</p></blockquote></li> <li><p><strong>HTTP/3.0</strong></p> <p>采用 <code>QUIC</code> 协议，基于 <code>UDP</code> 协议，避免了 <code>TCP</code> 协议的一些缺点，采用 <code>TLS1.3</code> 将 <code>HTTPS</code> 所需的 <code>RTT</code> 降至最少为0。</p> <ul><li><p><strong>TCP 协议的不足</strong></p> <ul><li><p><strong>TCP 可能会间歇性地挂起数据传输</strong>：如果一个序列号较低的数据段还没有接收到，即使其他序列号较高的段已经接收到，<code>TCP</code> 的接收机滑动窗口也不会继续处理。这将导致<code>TCP</code> 流瞬间挂起，在更糟糕的情况下，即使所有的段中有一个没有收到，也会导致关闭连接。这个问题被称为 <code>TCP</code> 流的<strong>行头阻塞（HoL）</strong></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14ff925a420948138dff59caa1e82c92~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211107141850885"></p></li> <li><p><strong>TCP 不支持流级复</strong>：虽然 <code>TCP</code> 确实允许在应用层之间建立多个逻辑连接，但它不允许在一个 <code>TCP</code> 流中复用数据包。使用 <code>HTTP/2</code> 时，浏览器只能与服务器打开一个 <code>TCP</code> 连接，并使用同一个连接来请求多个对象，如 <code>CSS</code>、<code>JavaScript</code> 等文件。在接收这些对象的同时，<code>TCP</code> 会将所有对象序列化在同一个流中。因此，它不知道 <code>TCP</code>段的对象级分区。</p></li> <li><p><strong>TCP 会产生冗余通信</strong>：<code>TCP</code> 连接握手会有冗余的消息交换序列，即使是与已知主机建立的连接也是如此。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f504a2cae7114b77bb975ca1f8c3c42d~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211107142702865"></p></li></ul></li> <li><p><strong>QUIC 协议的优势</strong></p> <ul><li><p><strong>选择UDP作为底层传输层协议</strong>：在 <code>TCP</code> 之上建立新的传输机制，将继承 <code>TCP</code> 的上述所有缺点。因此，<code>UDP</code> 是一个明智的选择。此外，<code>QUIC</code> 是在用户层构建的，所以不需要每次协议升级时进行内核修改。</p></li> <li><p><strong>流复用和流控</strong>：<code>QUIC</code> 引入了连接上的多路流复用的概念。 <code>QUIC</code> 通过设计实现了单独的、针对每个流的流控，解决了整个连接的行头阻塞问题。</p></li> <li><p><strong>灵活的拥塞控制机制</strong>：<code>TCP</code> 的拥塞控制机制是刚性的。该协议每次检测到拥塞时，都会将拥塞窗口大小减少一半。相比之下，<code>QUIC</code> 的拥塞控制设计得更加灵活，可以更有效地利用可用的网络带宽，从而获得更好的吞吐量。</p></li> <li><p><strong>更好的错误处理能力</strong>：<code>QUIC</code> 使用增强的丢失恢复机制和转发纠错功能，以更好地处理错误数据包。该功能对于那些只能通过缓慢的无线网络访问互联网的用户来说是一个福音，因为这些网络用户在传输过程中经常出现高错误率。</p></li> <li><p><strong>更快的握手</strong>：<code>QUIC</code> 使用相同的 <code>TLS</code> 模块进行安全连接。然而，与 <code>TCP</code> 不同的是，<code>QUIC</code> 的握手机制经过优化，避免了每次两个已知的对等者之间建立通信时的冗余协议交换。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7666e15f6f541daab9005557a716ed9~tplv-k3u1fbpfcp-watermark.awebp" alt="image-20211107142820199"></p></li></ul></li></ul></li></ul> <blockquote><p>这里大概给两条公式看下 HTTP/3 在结合 HTTPS 下跟 HTTP/2 的对比，给大家一个比较直观的感受，具体细节就不再简述了。毕竟本篇的主题不在这，如果有兴趣的话后面可以再详细讲。</p> <p><strong>HTTP/2下</strong>：HTTPS 通信时间总和 = TCP连接时间 + TLS 连接时间 + HTTP交易时间 = 1.5 RTT + 1.5 RTT + 1RTT = 4 RTT</p> <p><strong>HTTP/3下</strong>：首次链接时，QUIC 采用 TLS1.3，需要 1RTT，一次HTTP数据请求，共2RTT。重连时直接使用Session ID，不需要再次进行 TLS 验证，所以只需要 1RTT</p></blockquote> <p>OK，大概了解的 <code>HTTP</code> 协议的版本特点后，我们来看在目前主流 <code>HTTP2</code> + <code>HTTPS</code> 的时代下，哪些优化策略已经过时了甚至是反优化呢</p> <ol><li><strong>减少请求数</strong>：<code>HTTP/1.1</code> 因为存在「队头阻塞」，所以我们通常会采用合并资源，捆绑文件（雪碧图等）等方式来减少请求数。但在 <code>HTTP/2</code> 中我们更需要注重网站的缓存调优，传输轻量、细粒度的资源，方便独立缓存和并行传输。</li> <li><strong>多域名存储</strong>：<code>HTTP/1.1</code> 因为浏览器有最大连接数限制，所以我们会将资源分发到不同的域名下存放以此来增大最大连接数。但在 <code>HTTP/2</code> 中一个域只有一个链接，所以我们不需要去分多个域名存储，多域名存储甚至还会造成额外的 <code>TLS</code> 消耗。</li></ol> <h4 id="减小请求头的大小"><a href="#减小请求头的大小" class="header-anchor">#</a> 减小请求头的大小</h4> <p>减小请求头的大小，常见的情况是 <code>Cookie</code> 。例如我们的主站中（如：<code>www.test.com</code> ） 存储了很多的 <code>Cookie</code>，我们的 <code>CDN</code> 域名（<code>cdn.test.com</code>）与我们主域一样，此时我们去请求时会附带上 <code>.test.com</code>域下的 <code>Cookie</code>。而且这些 <code>Cookie</code> 对于 <code>CDN</code> 毫无用处，会增大我们请求的包大小。所以我们可以将 <code>CDN</code> 域名与主域区分开，例如：淘宝（<code>https://www.taobao.com</code>）的 <code>CDN</code> 域名为 <code>https://img.alicdn.com</code>。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <h4 id="优化工具"><a href="#优化工具" class="header-anchor">#</a> 优化工具</h4> <p>上面我们长篇大论的简述了许多前端优化的点，这里再推荐 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fspeed%2Fpagespeed%2Finsights%2F" title="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener noreferrer">PageSpeed Insights<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.webpagetest.org" title="https://www.webpagetest.org" target="_blank" rel="noopener noreferrer">WebPageTest<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 这两个工具。</p> <blockquote><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fspeed%2Fpagespeed%2Finsights%2F" title="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener noreferrer">PageSpeed Insights<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 可以帮助我们查看网站的各项 <code>RUM</code> 数据，同时会提供网站中的优化不足点，同时提供优化建议等。</p></blockquote> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58f9df8c2de2431a87adfd24e9fc8313~tplv-k3u1fbpfcp-watermark.awebp" alt="pagespeed_insights__url"></p> <blockquote><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.webpagetest.org" title="https://www.webpagetest.org" target="_blank" rel="noopener noreferrer">WebPageTest<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 免费提供了全球多个地点进行网站速度测试。还可以依据测试结果提供丰富的诊断信息，包括资源加载瀑布图，页面速度优化检查和改进建议，会给每一项内容一个最终的评级。</p></blockquote> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc372d949a4415183bfdb4a72fd6b60~tplv-k3u1fbpfcp-watermark.awebp" alt="webpagetest (1)"></p> <h4 id="速成方案"><a href="#速成方案" class="header-anchor">#</a> 速成方案</h4> <p>这个清单很庞大，如果要完成所有的优化可能需要很长时间。所以，如果你只有很有限的时间来进行优化，你会怎么做呢？让我们把它浓缩成<strong>15个比较容易实现的点</strong>。</p> <ol><li>根据实际经验制定合适的目标。一个比较合理的目标是：可视区域渲染 &lt; <strong>1s</strong>，页面渲染 &lt; <strong>3s</strong>，弱网 3G 的可操作时间 &lt; <strong>5s</strong>，重复访问的可交互时间(TTI) &lt; <strong>2s</strong>。</li> <li>为首屏准备关键 CSS，并将其内联在页面。对于 <code>CSS</code> / <code>JS</code>，关键文件大小控制在最大为<strong>压缩后 170KB</strong>内。</li> <li>抽离、优化、延迟加载尽可能多的脚本，选轻量级替代方案（如用 <code>DayJs</code> 代替 <code>MomentJs</code>），并限制第三方脚本的影响。</li> <li>仅向具有 <code>&lt;script type=&quot;module&quot;&gt;</code> 和 <strong>module/nomodule 模式</strong>的旧版本浏览器提供旧版本代码。</li> <li>尝试重新组合 <code>CSS</code> 规则。</li> <li>添加资源提示(<code>resource hints</code>)以提升页面加载速度，例如 <code>dns-prefetch</code>、<code>preconnect</code>、<code>prefetch</code>、<code>preload</code>、<code>prerender</code> 等。</li> <li>设置 Web 字体子集并异步加载，并利用 <code>CSS</code> 中的 <code>font-display</code> 实现快速的首次呈现。</li> <li>使用<strong>mozjpeg</strong>、 <strong>guetzli</strong>、 <strong>pingo</strong> 和 <strong>SVGOMG</strong>优化图像，并考虑使用图像 <code>CDN</code> 为 <code>WebP</code> 服务。</li> <li>检查 <code>HTTP</code> 缓存头和安全头是否设置正确。</li> <li>在服务器上启用 <code>Brotli</code> 压缩。（如果不行，那么请启用 <code>Gzip</code> 压缩。）</li> <li>只要服务器运行在 <code>Linux</code> 内核版本 4.9+上，就启用 <code>TCP BBR</code> 拥塞。</li> <li>如果可能，启用 <code>OCSP stapling</code>。</li> <li>如果 <code>HTTP/2</code> 可用，则启用 <code>HPACK</code> 压缩。如果激进一点可以尝试启用 <code>HTTP/3</code>。</li> <li>在 <code>Service worker</code> 中缓存字体、样式、JavaScript 和图像等资源。</li> <li>尝试使用渐进式 <code>hydration</code> 和流服务器渲染你的单页应用。</li></ol> <h3 id="参考文章"><a href="#参考文章" class="header-anchor">#</a> 参考文章</h3> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2021%2F01%2Ffront-end-performance-2021-free-pdf-checklist%2F" title="https://www.smashingmagazine.com/2021/01/front-end-performance-2021-free-pdf-checklist/" target="_blank" rel="noopener noreferrer">www.smashingmagazine.com/2021/01/fro…<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/7010647775880708133" title="https://juejin.cn/post/7010647775880708133" target="_blank" rel="noopener noreferrer">juejin.cn/post/701064…<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/6844903966573068301" title="https://juejin.cn/post/6844903966573068301" target="_blank" rel="noopener noreferrer">juejin.cn/post/684490…<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000023469150" title="https://segmentfault.com/a/1190000023469150" target="_blank" rel="noopener noreferrer">segmentfault.com/a/119000002…<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F1ad439279974" title="https://www.jianshu.com/p/1ad439279974" target="_blank" rel="noopener noreferrer">www.jianshu.com/p/1ad439279…<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F364991981" title="https://zhuanlan.zhihu.com/p/364991981" target="_blank" rel="noopener noreferrer">zhuanlan.zhihu.com/p/364991981<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F102382380" title="https://zhuanlan.zhihu.com/p/102382380" target="_blank" rel="noopener noreferrer">zhuanlan.zhihu.com/p/102382380<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fvitals%2F" title="https://web.dev/vitals/" target="_blank" rel="noopener noreferrer">web.dev/vitals/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-a008c6ba data-v-a008c6ba><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-a008c6ba><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-a008c6ba></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-a008c6ba></path></svg></div><div class="kanbanniang" data-v-ee8d62e6><div class="banniang-container" style="display:;" data-v-ee8d62e6><div class="messageBox" style="right:68px;bottom:190px;display:none;" data-v-ee8d62e6>
      欢迎来到 jun的个人空间
    </div> <div class="operation" style="right:90px;bottom:40px;display:;" data-v-ee8d62e6><i class="kbnfont kbn-ban-home ban-home" data-v-ee8d62e6></i> <i class="kbnfont kbn-ban-message message" data-v-ee8d62e6></i> <i class="kbnfont kbn-ban-close close" data-v-ee8d62e6></i> <a target="_blank" href="https://vuepress-theme-reco.recoluan.com/views/plugins/kanbanniang.html" data-v-ee8d62e6><i class="kbnfont kbn-ban-info info" data-v-ee8d62e6></i></a> <i class="kbnfont kbn-ban-theme skin" style="display:none;" data-v-ee8d62e6></i></div> <canvas id="banniang" width="150" height="220" class="live2d" style="position:fixed;left:0px;bottom:0px;opacity:0.9;z-index:99999;" data-v-ee8d62e6></canvas></div> <div class="showBanNiang" style="display:none;" data-v-ee8d62e6>
    看板娘
  </div></div><canvas id="vuepress-canvas-cursor"></canvas></div></div>
    <script src="/blog/assets/js/app.2e9aaf02.js" defer></script><script src="/blog/assets/js/3.df7e12f5.js" defer></script><script src="/blog/assets/js/1.71a2a4d1.js" defer></script><script src="/blog/assets/js/31.eeacc110.js" defer></script>
  </body>
</html>
